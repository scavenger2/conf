/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/node-fetch/browser.js"(exports, module2) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global2 !== "undefined") {
        return global2;
      }
      throw new Error("unable to locate global object");
    };
    var global2 = getGlobal();
    module2.exports = exports = global2.fetch;
    if (global2.fetch) {
      exports.default = global2.fetch.bind(global2);
    }
    exports.Headers = global2.Headers;
    exports.Request = global2.Request;
    exports.Response = global2.Response;
  }
});

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var luxon = {};
    Object.defineProperty(luxon, "__esModule", { value: true });
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it)
        return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        return function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var LuxonError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(LuxonError2, _Error);
      function LuxonError2() {
        return _Error.apply(this, arguments) || this;
      }
      return LuxonError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    var InvalidDateTimeError = /* @__PURE__ */ function(_LuxonError) {
      _inheritsLoose(InvalidDateTimeError2, _LuxonError);
      function InvalidDateTimeError2(reason) {
        return _LuxonError.call(this, "Invalid DateTime: " + reason.toMessage()) || this;
      }
      return InvalidDateTimeError2;
    }(LuxonError);
    var InvalidIntervalError = /* @__PURE__ */ function(_LuxonError2) {
      _inheritsLoose(InvalidIntervalError2, _LuxonError2);
      function InvalidIntervalError2(reason) {
        return _LuxonError2.call(this, "Invalid Interval: " + reason.toMessage()) || this;
      }
      return InvalidIntervalError2;
    }(LuxonError);
    var InvalidDurationError = /* @__PURE__ */ function(_LuxonError3) {
      _inheritsLoose(InvalidDurationError2, _LuxonError3);
      function InvalidDurationError2(reason) {
        return _LuxonError3.call(this, "Invalid Duration: " + reason.toMessage()) || this;
      }
      return InvalidDurationError2;
    }(LuxonError);
    var ConflictingSpecificationError = /* @__PURE__ */ function(_LuxonError4) {
      _inheritsLoose(ConflictingSpecificationError2, _LuxonError4);
      function ConflictingSpecificationError2() {
        return _LuxonError4.apply(this, arguments) || this;
      }
      return ConflictingSpecificationError2;
    }(LuxonError);
    var InvalidUnitError = /* @__PURE__ */ function(_LuxonError5) {
      _inheritsLoose(InvalidUnitError2, _LuxonError5);
      function InvalidUnitError2(unit) {
        return _LuxonError5.call(this, "Invalid unit " + unit) || this;
      }
      return InvalidUnitError2;
    }(LuxonError);
    var InvalidArgumentError = /* @__PURE__ */ function(_LuxonError6) {
      _inheritsLoose(InvalidArgumentError2, _LuxonError6);
      function InvalidArgumentError2() {
        return _LuxonError6.apply(this, arguments) || this;
      }
      return InvalidArgumentError2;
    }(LuxonError);
    var ZoneIsAbstractError = /* @__PURE__ */ function(_LuxonError7) {
      _inheritsLoose(ZoneIsAbstractError2, _LuxonError7);
      function ZoneIsAbstractError2() {
        return _LuxonError7.call(this, "Zone is an abstract class") || this;
      }
      return ZoneIsAbstractError2;
    }(LuxonError);
    var n = "numeric";
    var s = "short";
    var l = "long";
    var DATE_SHORT = {
      year: n,
      month: n,
      day: n
    };
    var DATE_MED = {
      year: n,
      month: s,
      day: n
    };
    var DATE_MED_WITH_WEEKDAY = {
      year: n,
      month: s,
      day: n,
      weekday: s
    };
    var DATE_FULL = {
      year: n,
      month: l,
      day: n
    };
    var DATE_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l
    };
    var TIME_SIMPLE = {
      hour: n,
      minute: n
    };
    var TIME_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n
    };
    var TIME_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s
    };
    var TIME_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    var TIME_24_SIMPLE = {
      hour: n,
      minute: n,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23",
      timeZoneName: s
    };
    var TIME_24_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23",
      timeZoneName: l
    };
    var DATETIME_SHORT = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_SHORT_WITH_SECONDS = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED = {
      year: n,
      month: s,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_MED_WITH_SECONDS = {
      year: n,
      month: s,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED_WITH_WEEKDAY = {
      year: n,
      month: s,
      day: n,
      weekday: s,
      hour: n,
      minute: n
    };
    var DATETIME_FULL = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      timeZoneName: s
    };
    var DATETIME_FULL_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s
    };
    var DATETIME_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      timeZoneName: l
    };
    var DATETIME_HUGE_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    function isUndefined(o) {
      return typeof o === "undefined";
    }
    function isNumber(o) {
      return typeof o === "number";
    }
    function isInteger(o) {
      return typeof o === "number" && o % 1 === 0;
    }
    function isString(o) {
      return typeof o === "string";
    }
    function isDate(o) {
      return Object.prototype.toString.call(o) === "[object Date]";
    }
    function hasRelative() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e) {
        return false;
      }
    }
    function maybeArray(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy(arr, by, compare) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce(function(best, next) {
        var pair = [by(next), next];
        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick(obj, keys) {
      return keys.reduce(function(a, k) {
        a[k] = obj[k];
        return a;
      }, {});
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween(thing, bottom, top) {
      return isInteger(thing) && thing >= bottom && thing <= top;
    }
    function floorMod(x, n2) {
      return x - n2 * Math.floor(x / n2);
    }
    function padStart(input, n2) {
      if (n2 === void 0) {
        n2 = 2;
      }
      var isNeg = input < 0;
      var padded;
      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n2, "0");
      } else {
        padded = ("" + input).padStart(n2, "0");
      }
      return padded;
    }
    function parseInteger(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseFloating(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseFloat(string);
      }
    }
    function parseMillis(fraction) {
      if (isUndefined(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        var f = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f);
      }
    }
    function roundTo(number, digits, towardZero) {
      if (towardZero === void 0) {
        towardZero = false;
      }
      var factor = Math.pow(10, digits), rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    }
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    function daysInMonth(year, month) {
      var modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS(obj) {
      var d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
      if (obj.year < 100 && obj.year >= 0) {
        d = new Date(d);
        d.setUTCFullYear(d.getUTCFullYear() - 1900);
      }
      return +d;
    }
    function weeksInWeekYear(weekYear) {
      var p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
      return p1 === 4 || p2 === 3 ? 53 : 52;
    }
    function untruncateYear(year) {
      if (year > 99) {
        return year;
      } else
        return year > 60 ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo(ts, offsetFormat, locale, timeZone) {
      if (timeZone === void 0) {
        timeZone = null;
      }
      var date = new Date(ts), intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      var modified = _extends({
        timeZoneName: offsetFormat
      }, intlOpts);
      var parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find(function(m) {
        return m.type.toLowerCase() === "timezonename";
      });
      return parsed ? parsed.value : null;
    }
    function signedOffset(offHourStr, offMinuteStr) {
      var offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      var offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber(value) {
      var numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
        throw new InvalidArgumentError("Invalid unit value " + value);
      return numericValue;
    }
    function normalizeObject(obj, normalizer) {
      var normalized = {};
      for (var u in obj) {
        if (hasOwnProperty(obj, u)) {
          var v = obj[u];
          if (v === void 0 || v === null)
            continue;
          normalized[normalizer(u)] = asNumber(v);
        }
      }
      return normalized;
    }
    function formatOffset(offset2, format) {
      var hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
      switch (format) {
        case "short":
          return "" + sign + padStart(hours, 2) + ":" + padStart(minutes, 2);
        case "narrow":
          return "" + sign + hours + (minutes > 0 ? ":" + minutes : "");
        case "techie":
          return "" + sign + padStart(hours, 2) + padStart(minutes, 2);
        default:
          throw new RangeError("Value format " + format + " is out of range for property format");
      }
    }
    function timeObject(obj) {
      return pick(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
    var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months(length) {
      switch (length) {
        case "narrow":
          return [].concat(monthsNarrow);
        case "short":
          return [].concat(monthsShort);
        case "long":
          return [].concat(monthsLong);
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
    var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays(length) {
      switch (length) {
        case "narrow":
          return [].concat(weekdaysNarrow);
        case "short":
          return [].concat(weekdaysShort);
        case "long":
          return [].concat(weekdaysLong);
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems = ["AM", "PM"];
    var erasLong = ["Before Christ", "Anno Domini"];
    var erasShort = ["BC", "AD"];
    var erasNarrow = ["B", "A"];
    function eras(length) {
      switch (length) {
        case "narrow":
          return [].concat(erasNarrow);
        case "short":
          return [].concat(erasShort);
        case "long":
          return [].concat(erasLong);
        default:
          return null;
      }
    }
    function meridiemForDateTime(dt) {
      return meridiems[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime(dt, length) {
      return weekdays(length)[dt.weekday - 1];
    }
    function monthForDateTime(dt, length) {
      return months(length)[dt.month - 1];
    }
    function eraForDateTime(dt, length) {
      return eras(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime(unit, count, numeric, narrow) {
      if (numeric === void 0) {
        numeric = "always";
      }
      if (narrow === void 0) {
        narrow = false;
      }
      var units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      var lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        var isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : "next " + units[unit][0];
          case -1:
            return isDay ? "yesterday" : "last " + units[unit][0];
          case 0:
            return isDay ? "today" : "this " + units[unit][0];
        }
      }
      var isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? fmtValue + " " + fmtUnit + " ago" : "in " + fmtValue + " " + fmtUnit;
    }
    function stringifyTokens(splits, tokenToString) {
      var s2 = "";
      for (var _iterator = _createForOfIteratorHelperLoose(splits), _step; !(_step = _iterator()).done; ) {
        var token = _step.value;
        if (token.literal) {
          s2 += token.val;
        } else {
          s2 += tokenToString(token.val);
        }
      }
      return s2;
    }
    var _macroTokenToFormatOpts = {
      D: DATE_SHORT,
      DD: DATE_MED,
      DDD: DATE_FULL,
      DDDD: DATE_HUGE,
      t: TIME_SIMPLE,
      tt: TIME_WITH_SECONDS,
      ttt: TIME_WITH_SHORT_OFFSET,
      tttt: TIME_WITH_LONG_OFFSET,
      T: TIME_24_SIMPLE,
      TT: TIME_24_WITH_SECONDS,
      TTT: TIME_24_WITH_SHORT_OFFSET,
      TTTT: TIME_24_WITH_LONG_OFFSET,
      f: DATETIME_SHORT,
      ff: DATETIME_MED,
      fff: DATETIME_FULL,
      ffff: DATETIME_HUGE,
      F: DATETIME_SHORT_WITH_SECONDS,
      FF: DATETIME_MED_WITH_SECONDS,
      FFF: DATETIME_FULL_WITH_SECONDS,
      FFFF: DATETIME_HUGE_WITH_SECONDS
    };
    var Formatter = /* @__PURE__ */ function() {
      Formatter2.create = function create(locale, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return new Formatter2(locale, opts);
      };
      Formatter2.parseFormat = function parseFormat(fmt) {
        var current = null, currentFull = "", bracketed = false;
        var splits = [];
        for (var i = 0; i < fmt.length; i++) {
          var c = fmt.charAt(i);
          if (c === "'") {
            if (currentFull.length > 0) {
              splits.push({
                literal: bracketed,
                val: currentFull
              });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c;
          } else if (c === current) {
            currentFull += c;
          } else {
            if (currentFull.length > 0) {
              splits.push({
                literal: false,
                val: currentFull
              });
            }
            currentFull = c;
            current = c;
          }
        }
        if (currentFull.length > 0) {
          splits.push({
            literal: bracketed,
            val: currentFull
          });
        }
        return splits;
      };
      Formatter2.macroTokenToFormatOpts = function macroTokenToFormatOpts(token) {
        return _macroTokenToFormatOpts[token];
      };
      function Formatter2(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      var _proto = Formatter2.prototype;
      _proto.formatWithSystemDefault = function formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        var df = this.systemLoc.dtFormatter(dt, _extends({}, this.opts, opts));
        return df.format();
      };
      _proto.formatDateTime = function formatDateTime(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var df = this.loc.dtFormatter(dt, _extends({}, this.opts, opts));
        return df.format();
      };
      _proto.formatDateTimeParts = function formatDateTimeParts(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var df = this.loc.dtFormatter(dt, _extends({}, this.opts, opts));
        return df.formatToParts();
      };
      _proto.resolvedOptions = function resolvedOptions(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var df = this.loc.dtFormatter(dt, _extends({}, this.opts, opts));
        return df.resolvedOptions();
      };
      _proto.num = function num(n2, p) {
        if (p === void 0) {
          p = 0;
        }
        if (this.opts.forceSimple) {
          return padStart(n2, p);
        }
        var opts = _extends({}, this.opts);
        if (p > 0) {
          opts.padTo = p;
        }
        return this.loc.numberFormatter(opts).format(n2);
      };
      _proto.formatDateTimeFromString = function formatDateTimeFromString(dt, fmt) {
        var _this = this;
        var knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = function string2(opts, extract) {
          return _this.loc.extract(dt, opts, extract);
        }, formatOffset2 = function formatOffset3(opts) {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = function meridiem2() {
          return knownEnglish ? meridiemForDateTime(dt) : string({
            hour: "numeric",
            hourCycle: "h12"
          }, "dayperiod");
        }, month = function month2(length, standalone) {
          return knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
            month: length
          } : {
            month: length,
            day: "numeric"
          }, "month");
        }, weekday = function weekday2(length, standalone) {
          return knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
            weekday: length
          } : {
            weekday: length,
            month: "long",
            day: "numeric"
          }, "weekday");
        }, maybeMacro = function maybeMacro2(token) {
          var formatOpts = Formatter2.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return _this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = function era2(length) {
          return knownEnglish ? eraForDateTime(dt, length) : string({
            era: length
          }, "era");
        }, tokenToString = function tokenToString2(token) {
          switch (token) {
            case "S":
              return _this.num(dt.millisecond);
            case "u":
            case "SSS":
              return _this.num(dt.millisecond, 3);
            case "s":
              return _this.num(dt.second);
            case "ss":
              return _this.num(dt.second, 2);
            case "uu":
              return _this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return _this.num(Math.floor(dt.millisecond / 100));
            case "m":
              return _this.num(dt.minute);
            case "mm":
              return _this.num(dt.minute, 2);
            case "h":
              return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return _this.num(dt.hour);
            case "HH":
              return _this.num(dt.hour, 2);
            case "Z":
              return formatOffset2({
                format: "narrow",
                allowZ: _this.opts.allowZ
              });
            case "ZZ":
              return formatOffset2({
                format: "short",
                allowZ: _this.opts.allowZ
              });
            case "ZZZ":
              return formatOffset2({
                format: "techie",
                allowZ: _this.opts.allowZ
              });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, {
                format: "short",
                locale: _this.loc.locale
              });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, {
                format: "long",
                locale: _this.loc.locale
              });
            case "z":
              return dt.zoneName;
            case "a":
              return meridiem();
            case "d":
              return useDateTimeFormatter ? string({
                day: "numeric"
              }, "day") : _this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({
                day: "2-digit"
              }, "day") : _this.num(dt.day, 2);
            case "c":
              return _this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            case "E":
              return _this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            case "L":
              return useDateTimeFormatter ? string({
                month: "numeric",
                day: "numeric"
              }, "month") : _this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string({
                month: "2-digit",
                day: "numeric"
              }, "month") : _this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            case "M":
              return useDateTimeFormatter ? string({
                month: "numeric"
              }, "month") : _this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string({
                month: "2-digit"
              }, "month") : _this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            case "y":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string({
                year: "2-digit"
              }, "year") : _this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year, 6);
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return _this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return _this.num(dt.weekYear, 4);
            case "W":
              return _this.num(dt.weekNumber);
            case "WW":
              return _this.num(dt.weekNumber, 2);
            case "o":
              return _this.num(dt.ordinal);
            case "ooo":
              return _this.num(dt.ordinal, 3);
            case "q":
              return _this.num(dt.quarter);
            case "qq":
              return _this.num(dt.quarter, 2);
            case "X":
              return _this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return _this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens(Formatter2.parseFormat(fmt), tokenToString);
      };
      _proto.formatDurationFromString = function formatDurationFromString(dur, fmt) {
        var _this2 = this;
        var tokenToField = function tokenToField2(token) {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "w":
              return "week";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        }, tokenToString = function tokenToString2(lildur) {
          return function(token) {
            var mapped = tokenToField(token);
            if (mapped) {
              return _this2.num(lildur.get(mapped), token.length);
            } else {
              return token;
            }
          };
        }, tokens = Formatter2.parseFormat(fmt), realTokens = tokens.reduce(function(found, _ref) {
          var literal = _ref.literal, val = _ref.val;
          return literal ? found : found.concat(val);
        }, []), collapsed = dur.shiftTo.apply(dur, realTokens.map(tokenToField).filter(function(t) {
          return t;
        }));
        return stringifyTokens(tokens, tokenToString(collapsed));
      };
      return Formatter2;
    }();
    var Invalid = /* @__PURE__ */ function() {
      function Invalid2(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      var _proto = Invalid2.prototype;
      _proto.toMessage = function toMessage() {
        if (this.explanation) {
          return this.reason + ": " + this.explanation;
        } else {
          return this.reason;
        }
      };
      return Invalid2;
    }();
    var Zone = /* @__PURE__ */ function() {
      function Zone2() {
      }
      var _proto = Zone2.prototype;
      _proto.offsetName = function offsetName(ts, opts) {
        throw new ZoneIsAbstractError();
      };
      _proto.formatOffset = function formatOffset2(ts, format) {
        throw new ZoneIsAbstractError();
      };
      _proto.offset = function offset2(ts) {
        throw new ZoneIsAbstractError();
      };
      _proto.equals = function equals(otherZone) {
        throw new ZoneIsAbstractError();
      };
      _createClass(Zone2, [{
        key: "type",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }, {
        key: "name",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }, {
        key: "ianaName",
        get: function get() {
          return this.name;
        }
      }, {
        key: "isUniversal",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }, {
        key: "isValid",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }]);
      return Zone2;
    }();
    var singleton$1 = null;
    var SystemZone = /* @__PURE__ */ function(_Zone) {
      _inheritsLoose(SystemZone2, _Zone);
      function SystemZone2() {
        return _Zone.apply(this, arguments) || this;
      }
      var _proto = SystemZone2.prototype;
      _proto.offsetName = function offsetName(ts, _ref) {
        var format = _ref.format, locale = _ref.locale;
        return parseZoneInfo(ts, format, locale);
      };
      _proto.formatOffset = function formatOffset$1(ts, format) {
        return formatOffset(this.offset(ts), format);
      };
      _proto.offset = function offset2(ts) {
        return -new Date(ts).getTimezoneOffset();
      };
      _proto.equals = function equals(otherZone) {
        return otherZone.type === "system";
      };
      _createClass(SystemZone2, [{
        key: "type",
        get: function get() {
          return "system";
        }
      }, {
        key: "name",
        get: function get() {
          return new Intl.DateTimeFormat().resolvedOptions().timeZone;
        }
      }, {
        key: "isUniversal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return true;
        }
      }], [{
        key: "instance",
        get: function get() {
          if (singleton$1 === null) {
            singleton$1 = new SystemZone2();
          }
          return singleton$1;
        }
      }]);
      return SystemZone2;
    }(Zone);
    var dtfCache = {};
    function makeDTF(zone) {
      if (!dtfCache[zone]) {
        dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          era: "short"
        });
      }
      return dtfCache[zone];
    }
    var typeToPos = {
      year: 0,
      month: 1,
      day: 2,
      era: 3,
      hour: 4,
      minute: 5,
      second: 6
    };
    function hackyOffset(dtf, date) {
      var formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), fMonth = parsed[1], fDay = parsed[2], fYear = parsed[3], fadOrBc = parsed[4], fHour = parsed[5], fMinute = parsed[6], fSecond = parsed[7];
      return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
    }
    function partsOffset(dtf, date) {
      var formatted = dtf.formatToParts(date);
      var filled = [];
      for (var i = 0; i < formatted.length; i++) {
        var _formatted$i = formatted[i], type = _formatted$i.type, value = _formatted$i.value;
        var pos = typeToPos[type];
        if (type === "era") {
          filled[pos] = value;
        } else if (!isUndefined(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache = {};
    var IANAZone = /* @__PURE__ */ function(_Zone) {
      _inheritsLoose(IANAZone2, _Zone);
      IANAZone2.create = function create(name) {
        if (!ianaZoneCache[name]) {
          ianaZoneCache[name] = new IANAZone2(name);
        }
        return ianaZoneCache[name];
      };
      IANAZone2.resetCache = function resetCache() {
        ianaZoneCache = {};
        dtfCache = {};
      };
      IANAZone2.isValidSpecifier = function isValidSpecifier(s2) {
        return this.isValidZone(s2);
      };
      IANAZone2.isValidZone = function isValidZone(zone) {
        if (!zone) {
          return false;
        }
        try {
          new Intl.DateTimeFormat("en-US", {
            timeZone: zone
          }).format();
          return true;
        } catch (e) {
          return false;
        }
      };
      function IANAZone2(name) {
        var _this;
        _this = _Zone.call(this) || this;
        _this.zoneName = name;
        _this.valid = IANAZone2.isValidZone(name);
        return _this;
      }
      var _proto = IANAZone2.prototype;
      _proto.offsetName = function offsetName(ts, _ref) {
        var format = _ref.format, locale = _ref.locale;
        return parseZoneInfo(ts, format, locale, this.name);
      };
      _proto.formatOffset = function formatOffset$1(ts, format) {
        return formatOffset(this.offset(ts), format);
      };
      _proto.offset = function offset2(ts) {
        var date = new Date(ts);
        if (isNaN(date))
          return NaN;
        var dtf = makeDTF(this.name);
        var _ref2 = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date), year = _ref2[0], month = _ref2[1], day = _ref2[2], adOrBc = _ref2[3], hour = _ref2[4], minute = _ref2[5], second = _ref2[6];
        if (adOrBc === "BC") {
          year = -Math.abs(year) + 1;
        }
        var adjustedHour = hour === 24 ? 0 : hour;
        var asUTC = objToLocalTS({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        var asTS = +date;
        var over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      };
      _proto.equals = function equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      };
      _createClass(IANAZone2, [{
        key: "type",
        get: function get() {
          return "iana";
        }
      }, {
        key: "name",
        get: function get() {
          return this.zoneName;
        }
      }, {
        key: "isUniversal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return this.valid;
        }
      }]);
      return IANAZone2;
    }(Zone);
    var singleton = null;
    var FixedOffsetZone = /* @__PURE__ */ function(_Zone) {
      _inheritsLoose(FixedOffsetZone2, _Zone);
      FixedOffsetZone2.instance = function instance(offset2) {
        return offset2 === 0 ? FixedOffsetZone2.utcInstance : new FixedOffsetZone2(offset2);
      };
      FixedOffsetZone2.parseSpecifier = function parseSpecifier(s2) {
        if (s2) {
          var r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r) {
            return new FixedOffsetZone2(signedOffset(r[1], r[2]));
          }
        }
        return null;
      };
      function FixedOffsetZone2(offset2) {
        var _this;
        _this = _Zone.call(this) || this;
        _this.fixed = offset2;
        return _this;
      }
      var _proto = FixedOffsetZone2.prototype;
      _proto.offsetName = function offsetName() {
        return this.name;
      };
      _proto.formatOffset = function formatOffset$1(ts, format) {
        return formatOffset(this.fixed, format);
      };
      _proto.offset = function offset2() {
        return this.fixed;
      };
      _proto.equals = function equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      };
      _createClass(FixedOffsetZone2, [{
        key: "type",
        get: function get() {
          return "fixed";
        }
      }, {
        key: "name",
        get: function get() {
          return this.fixed === 0 ? "UTC" : "UTC" + formatOffset(this.fixed, "narrow");
        }
      }, {
        key: "ianaName",
        get: function get() {
          if (this.fixed === 0) {
            return "Etc/UTC";
          } else {
            return "Etc/GMT" + formatOffset(-this.fixed, "narrow");
          }
        }
      }, {
        key: "isUniversal",
        get: function get() {
          return true;
        }
      }, {
        key: "isValid",
        get: function get() {
          return true;
        }
      }], [{
        key: "utcInstance",
        get: function get() {
          if (singleton === null) {
            singleton = new FixedOffsetZone2(0);
          }
          return singleton;
        }
      }]);
      return FixedOffsetZone2;
    }(Zone);
    var InvalidZone = /* @__PURE__ */ function(_Zone) {
      _inheritsLoose(InvalidZone2, _Zone);
      function InvalidZone2(zoneName) {
        var _this;
        _this = _Zone.call(this) || this;
        _this.zoneName = zoneName;
        return _this;
      }
      var _proto = InvalidZone2.prototype;
      _proto.offsetName = function offsetName() {
        return null;
      };
      _proto.formatOffset = function formatOffset2() {
        return "";
      };
      _proto.offset = function offset2() {
        return NaN;
      };
      _proto.equals = function equals() {
        return false;
      };
      _createClass(InvalidZone2, [{
        key: "type",
        get: function get() {
          return "invalid";
        }
      }, {
        key: "name",
        get: function get() {
          return this.zoneName;
        }
      }, {
        key: "isUniversal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return false;
        }
      }]);
      return InvalidZone2;
    }(Zone);
    function normalizeZone(input, defaultZone2) {
      if (isUndefined(input) || input === null) {
        return defaultZone2;
      } else if (input instanceof Zone) {
        return input;
      } else if (isString(input)) {
        var lowered = input.toLowerCase();
        if (lowered === "local" || lowered === "system")
          return defaultZone2;
        else if (lowered === "utc" || lowered === "gmt")
          return FixedOffsetZone.utcInstance;
        else
          return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
      } else if (isNumber(input)) {
        return FixedOffsetZone.instance(input);
      } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
        return input;
      } else {
        return new InvalidZone(input);
      }
    }
    var now = function now2() {
      return Date.now();
    };
    var defaultZone = "system";
    var defaultLocale = null;
    var defaultNumberingSystem = null;
    var defaultOutputCalendar = null;
    var throwOnInvalid;
    var Settings = /* @__PURE__ */ function() {
      function Settings2() {
      }
      Settings2.resetCaches = function resetCaches() {
        Locale.resetCache();
        IANAZone.resetCache();
      };
      _createClass(Settings2, null, [{
        key: "now",
        get: function get() {
          return now;
        },
        set: function set(n2) {
          now = n2;
        }
      }, {
        key: "defaultZone",
        get: function get() {
          return normalizeZone(defaultZone, SystemZone.instance);
        },
        set: function set(zone) {
          defaultZone = zone;
        }
      }, {
        key: "defaultLocale",
        get: function get() {
          return defaultLocale;
        },
        set: function set(locale) {
          defaultLocale = locale;
        }
      }, {
        key: "defaultNumberingSystem",
        get: function get() {
          return defaultNumberingSystem;
        },
        set: function set(numberingSystem) {
          defaultNumberingSystem = numberingSystem;
        }
      }, {
        key: "defaultOutputCalendar",
        get: function get() {
          return defaultOutputCalendar;
        },
        set: function set(outputCalendar) {
          defaultOutputCalendar = outputCalendar;
        }
      }, {
        key: "throwOnInvalid",
        get: function get() {
          return throwOnInvalid;
        },
        set: function set(t) {
          throwOnInvalid = t;
        }
      }]);
      return Settings2;
    }();
    var _excluded = ["base"];
    var _excluded2 = ["padTo", "floor"];
    var intlLFCache = {};
    function getCachedLF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var key = JSON.stringify([locString, opts]);
      var dtf = intlLFCache[key];
      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache[key] = dtf;
      }
      return dtf;
    }
    var intlDTCache = {};
    function getCachedDTF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var key = JSON.stringify([locString, opts]);
      var dtf = intlDTCache[key];
      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache[key] = dtf;
      }
      return dtf;
    }
    var intlNumCache = {};
    function getCachedINF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var key = JSON.stringify([locString, opts]);
      var inf = intlNumCache[key];
      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache[key] = inf;
      }
      return inf;
    }
    var intlRelCache = {};
    function getCachedRTF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var _opts = opts;
      _opts.base;
      var cacheKeyOpts = _objectWithoutPropertiesLoose(_opts, _excluded);
      var key = JSON.stringify([locString, cacheKeyOpts]);
      var inf = intlRelCache[key];
      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache[key] = inf;
      }
      return inf;
    }
    var sysLocaleCache = null;
    function systemLocale() {
      if (sysLocaleCache) {
        return sysLocaleCache;
      } else {
        sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache;
      }
    }
    function parseLocaleString(localeStr) {
      var uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        var options;
        var smaller = localeStr.substring(0, uIndex);
        try {
          options = getCachedDTF(localeStr).resolvedOptions();
        } catch (e) {
          options = getCachedDTF(smaller).resolvedOptions();
        }
        var _options = options, numberingSystem = _options.numberingSystem, calendar = _options.calendar;
        return [smaller, numberingSystem, calendar];
      }
    }
    function intlConfigString(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        localeStr += "-u";
        if (outputCalendar) {
          localeStr += "-ca-" + outputCalendar;
        }
        if (numberingSystem) {
          localeStr += "-nu-" + numberingSystem;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    }
    function mapMonths(f) {
      var ms = [];
      for (var i = 1; i <= 12; i++) {
        var dt = DateTime.utc(2016, i, 1);
        ms.push(f(dt));
      }
      return ms;
    }
    function mapWeekdays(f) {
      var ms = [];
      for (var i = 1; i <= 7; i++) {
        var dt = DateTime.utc(2016, 11, 13 + i);
        ms.push(f(dt));
      }
      return ms;
    }
    function listStuff(loc, length, defaultOK, englishFn, intlFn) {
      var mode = loc.listingMode(defaultOK);
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }
    function supportsFastNumbers(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter = /* @__PURE__ */ function() {
      function PolyNumberFormatter2(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        opts.padTo;
        opts.floor;
        var otherOpts = _objectWithoutPropertiesLoose(opts, _excluded2);
        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          var intlOpts = _extends({
            useGrouping: false
          }, opts);
          if (opts.padTo > 0)
            intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF(intl, intlOpts);
        }
      }
      var _proto = PolyNumberFormatter2.prototype;
      _proto.format = function format(i) {
        if (this.inf) {
          var fixed = this.floor ? Math.floor(i) : i;
          return this.inf.format(fixed);
        } else {
          var _fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
          return padStart(_fixed, this.padTo);
        }
      };
      return PolyNumberFormatter2;
    }();
    var PolyDateFormatter = /* @__PURE__ */ function() {
      function PolyDateFormatter2(dt, intl, opts) {
        this.opts = opts;
        var z;
        if (dt.zone.isUniversal) {
          var gmtOffset = -1 * (dt.offset / 60);
          var offsetZ = gmtOffset >= 0 ? "Etc/GMT+" + gmtOffset : "Etc/GMT" + gmtOffset;
          if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
            z = offsetZ;
            this.dt = dt;
          } else {
            z = "UTC";
            if (opts.timeZoneName) {
              this.dt = dt;
            } else {
              this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1e3);
            }
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else {
          this.dt = dt;
          z = dt.zone.name;
        }
        var intlOpts = _extends({}, this.opts);
        if (z) {
          intlOpts.timeZone = z;
        }
        this.dtf = getCachedDTF(intl, intlOpts);
      }
      var _proto2 = PolyDateFormatter2.prototype;
      _proto2.format = function format() {
        return this.dtf.format(this.dt.toJSDate());
      };
      _proto2.formatToParts = function formatToParts() {
        return this.dtf.formatToParts(this.dt.toJSDate());
      };
      _proto2.resolvedOptions = function resolvedOptions() {
        return this.dtf.resolvedOptions();
      };
      return PolyDateFormatter2;
    }();
    var PolyRelFormatter = /* @__PURE__ */ function() {
      function PolyRelFormatter2(intl, isEnglish, opts) {
        this.opts = _extends({
          style: "long"
        }, opts);
        if (!isEnglish && hasRelative()) {
          this.rtf = getCachedRTF(intl, opts);
        }
      }
      var _proto3 = PolyRelFormatter2.prototype;
      _proto3.format = function format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      };
      _proto3.formatToParts = function formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      };
      return PolyRelFormatter2;
    }();
    var Locale = /* @__PURE__ */ function() {
      Locale2.fromOpts = function fromOpts(opts) {
        return Locale2.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      };
      Locale2.create = function create(locale, numberingSystem, outputCalendar, defaultToEN) {
        if (defaultToEN === void 0) {
          defaultToEN = false;
        }
        var specifiedLocale = locale || Settings.defaultLocale;
        var localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
        var numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
        var outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
        return new Locale2(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      };
      Locale2.resetCache = function resetCache() {
        sysLocaleCache = null;
        intlDTCache = {};
        intlNumCache = {};
        intlRelCache = {};
      };
      Locale2.fromObject = function fromObject(_temp) {
        var _ref = _temp === void 0 ? {} : _temp, locale = _ref.locale, numberingSystem = _ref.numberingSystem, outputCalendar = _ref.outputCalendar;
        return Locale2.create(locale, numberingSystem, outputCalendar);
      };
      function Locale2(locale, numbering, outputCalendar, specifiedLocale) {
        var _parseLocaleString = parseLocaleString(locale), parsedLocale = _parseLocaleString[0], parsedNumberingSystem = _parseLocaleString[1], parsedOutputCalendar = _parseLocaleString[2];
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = {
          format: {},
          standalone: {}
        };
        this.monthsCache = {
          format: {},
          standalone: {}
        };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      var _proto4 = Locale2.prototype;
      _proto4.listingMode = function listingMode() {
        var isActuallyEn = this.isEnglish();
        var hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      };
      _proto4.clone = function clone2(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return Locale2.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
        }
      };
      _proto4.redefaultToEN = function redefaultToEN(alts) {
        if (alts === void 0) {
          alts = {};
        }
        return this.clone(_extends({}, alts, {
          defaultToEN: true
        }));
      };
      _proto4.redefaultToSystem = function redefaultToSystem(alts) {
        if (alts === void 0) {
          alts = {};
        }
        return this.clone(_extends({}, alts, {
          defaultToEN: false
        }));
      };
      _proto4.months = function months$1(length, format, defaultOK) {
        var _this = this;
        if (format === void 0) {
          format = false;
        }
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, length, defaultOK, months, function() {
          var intl = format ? {
            month: length,
            day: "numeric"
          } : {
            month: length
          }, formatStr2 = format ? "format" : "standalone";
          if (!_this.monthsCache[formatStr2][length]) {
            _this.monthsCache[formatStr2][length] = mapMonths(function(dt) {
              return _this.extract(dt, intl, "month");
            });
          }
          return _this.monthsCache[formatStr2][length];
        });
      };
      _proto4.weekdays = function weekdays$1(length, format, defaultOK) {
        var _this2 = this;
        if (format === void 0) {
          format = false;
        }
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, length, defaultOK, weekdays, function() {
          var intl = format ? {
            weekday: length,
            year: "numeric",
            month: "long",
            day: "numeric"
          } : {
            weekday: length
          }, formatStr2 = format ? "format" : "standalone";
          if (!_this2.weekdaysCache[formatStr2][length]) {
            _this2.weekdaysCache[formatStr2][length] = mapWeekdays(function(dt) {
              return _this2.extract(dt, intl, "weekday");
            });
          }
          return _this2.weekdaysCache[formatStr2][length];
        });
      };
      _proto4.meridiems = function meridiems$1(defaultOK) {
        var _this3 = this;
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, void 0, defaultOK, function() {
          return meridiems;
        }, function() {
          if (!_this3.meridiemCache) {
            var intl = {
              hour: "numeric",
              hourCycle: "h12"
            };
            _this3.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(function(dt) {
              return _this3.extract(dt, intl, "dayperiod");
            });
          }
          return _this3.meridiemCache;
        });
      };
      _proto4.eras = function eras$1(length, defaultOK) {
        var _this4 = this;
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, length, defaultOK, eras, function() {
          var intl = {
            era: length
          };
          if (!_this4.eraCache[length]) {
            _this4.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(function(dt) {
              return _this4.extract(dt, intl, "era");
            });
          }
          return _this4.eraCache[length];
        });
      };
      _proto4.extract = function extract(dt, intlOpts, field) {
        var df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find(function(m) {
          return m.type.toLowerCase() === field;
        });
        return matching ? matching.value : null;
      };
      _proto4.numberFormatter = function numberFormatter(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
      };
      _proto4.dtFormatter = function dtFormatter(dt, intlOpts) {
        if (intlOpts === void 0) {
          intlOpts = {};
        }
        return new PolyDateFormatter(dt, this.intl, intlOpts);
      };
      _proto4.relFormatter = function relFormatter(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
      };
      _proto4.listFormatter = function listFormatter(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return getCachedLF(this.intl, opts);
      };
      _proto4.isEnglish = function isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      };
      _proto4.equals = function equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      };
      _createClass(Locale2, [{
        key: "fastNumbers",
        get: function get() {
          if (this.fastNumbersCached == null) {
            this.fastNumbersCached = supportsFastNumbers(this);
          }
          return this.fastNumbersCached;
        }
      }]);
      return Locale2;
    }();
    function combineRegexes() {
      for (var _len = arguments.length, regexes = new Array(_len), _key = 0; _key < _len; _key++) {
        regexes[_key] = arguments[_key];
      }
      var full = regexes.reduce(function(f, r) {
        return f + r.source;
      }, "");
      return RegExp("^" + full + "$");
    }
    function combineExtractors() {
      for (var _len2 = arguments.length, extractors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        extractors[_key2] = arguments[_key2];
      }
      return function(m) {
        return extractors.reduce(function(_ref, ex) {
          var mergedVals = _ref[0], mergedZone = _ref[1], cursor = _ref[2];
          var _ex = ex(m, cursor), val = _ex[0], zone = _ex[1], next = _ex[2];
          return [_extends({}, mergedVals, val), zone || mergedZone, next];
        }, [{}, null, 1]).slice(0, 2);
      };
    }
    function parse(s2) {
      if (s2 == null) {
        return [null, null];
      }
      for (var _len3 = arguments.length, patterns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        patterns[_key3 - 1] = arguments[_key3];
      }
      for (var _i = 0, _patterns = patterns; _i < _patterns.length; _i++) {
        var _patterns$_i = _patterns[_i], regex = _patterns$_i[0], extractor = _patterns$_i[1];
        var m = regex.exec(s2);
        if (m) {
          return extractor(m);
        }
      }
      return [null, null];
    }
    function simpleParse() {
      for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        keys[_key4] = arguments[_key4];
      }
      return function(match2, cursor) {
        var ret = {};
        var i;
        for (i = 0; i < keys.length; i++) {
          ret[keys[i]] = parseInteger(match2[cursor + i]);
        }
        return [ret, null, cursor + i];
      };
    }
    var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
    var isoExtendedZone = "(?:" + offsetRegex.source + "?(?:\\[(" + ianaRegex.source + ")\\])?)?";
    var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex = RegExp("" + isoTimeBaseRegex.source + isoExtendedZone);
    var isoTimeExtensionRegex = RegExp("(?:T" + isoTimeRegex.source + ")?");
    var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
    var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData = simpleParse("year", "ordinal");
    var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex = RegExp(isoTimeBaseRegex.source + " ?(?:" + offsetRegex.source + "|(" + ianaRegex.source + "))?");
    var sqlTimeExtensionRegex = RegExp("(?: " + sqlTimeRegex.source + ")?");
    function int(match2, pos, fallback) {
      var m = match2[pos];
      return isUndefined(m) ? fallback : parseInteger(m);
    }
    function extractISOYmd(match2, cursor) {
      var item = {
        year: int(match2, cursor),
        month: int(match2, cursor + 1, 1),
        day: int(match2, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime(match2, cursor) {
      var item = {
        hours: int(match2, cursor, 0),
        minutes: int(match2, cursor + 1, 0),
        seconds: int(match2, cursor + 2, 0),
        milliseconds: parseMillis(match2[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset(match2, cursor) {
      var local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone(match2, cursor) {
      var zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly = RegExp("^T?" + isoTimeBaseRegex.source + "$");
    var isoDuration = /^-?P(?:(?:(-?\d{1,9}(?:\.\d{1,9})?)Y)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,9}(?:\.\d{1,9})?)W)?(?:(-?\d{1,9}(?:\.\d{1,9})?)D)?(?:T(?:(-?\d{1,9}(?:\.\d{1,9})?)H)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;
    function extractISODuration(match2) {
      var s2 = match2[0], yearStr = match2[1], monthStr = match2[2], weekStr = match2[3], dayStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], millisecondsStr = match2[8];
      var hasNegativePrefix = s2[0] === "-";
      var negativeSeconds = secondStr && secondStr[0] === "-";
      var maybeNegate = function maybeNegate2(num, force) {
        if (force === void 0) {
          force = false;
        }
        return num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      };
      return [{
        years: maybeNegate(parseFloating(yearStr)),
        months: maybeNegate(parseFloating(monthStr)),
        weeks: maybeNegate(parseFloating(weekStr)),
        days: maybeNegate(parseFloating(dayStr)),
        hours: maybeNegate(parseFloating(hourStr)),
        minutes: maybeNegate(parseFloating(minuteStr)),
        seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
        milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
      }];
    }
    var obsOffsets = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = {
        year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
        month: monthsShort.indexOf(monthStr) + 1,
        day: parseInteger(dayStr),
        hour: parseInteger(hourStr),
        minute: parseInteger(minuteStr)
      };
      if (secondStr)
        result.second = parseInteger(secondStr);
      if (weekdayStr) {
        result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
      }
      return result;
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC2822(match2) {
      var weekdayStr = match2[1], dayStr = match2[2], monthStr = match2[3], yearStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], obsOffset = match2[8], milOffset = match2[9], offHourStr = match2[10], offMinuteStr = match2[11], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      var offset2;
      if (obsOffset) {
        offset2 = obsOffsets[obsOffset];
      } else if (milOffset) {
        offset2 = 0;
      } else {
        offset2 = signedOffset(offHourStr, offMinuteStr);
      }
      return [result, new FixedOffsetZone(offset2)];
    }
    function preprocessRFC2822(s2) {
      return s2.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc850 = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or850(match2) {
      var weekdayStr = match2[1], dayStr = match2[2], monthStr = match2[3], yearStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    function extractASCII(match2) {
      var weekdayStr = match2[1], monthStr = match2[2], dayStr = match2[3], hourStr = match2[4], minuteStr = match2[5], secondStr = match2[6], yearStr = match2[7], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
    var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
    var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
    var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
    var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
    var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
    var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
    var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
    function parseISODate(s2) {
      return parse(s2, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
    }
    function parseRFC2822Date(s2) {
      return parse(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
    }
    function parseHTTPDate(s2) {
      return parse(s2, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
    }
    function parseISODuration(s2) {
      return parse(s2, [isoDuration, extractISODuration]);
    }
    var extractISOTimeOnly = combineExtractors(extractISOTime);
    function parseISOTimeOnly(s2) {
      return parse(s2, [isoTimeOnly, extractISOTimeOnly]);
    }
    var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
    var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
    var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
    function parseSQL(s2) {
      return parse(s2, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
    }
    var INVALID$2 = "Invalid Duration";
    var lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: {
        minutes: 60,
        seconds: 60 * 60,
        milliseconds: 60 * 60 * 1e3
      },
      minutes: {
        seconds: 60,
        milliseconds: 60 * 1e3
      },
      seconds: {
        milliseconds: 1e3
      }
    };
    var casualMatrix = _extends({
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      }
    }, lowOrderMatrix);
    var daysInYearAccurate = 146097 / 400;
    var daysInMonthAccurate = 146097 / 4800;
    var accurateMatrix = _extends({
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: daysInYearAccurate * 24 / 4,
        minutes: daysInYearAccurate * 24 * 60 / 4,
        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
      }
    }, lowOrderMatrix);
    var orderedUnits$1 = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
    var reverseUnits = orderedUnits$1.slice(0).reverse();
    function clone$1(dur, alts, clear) {
      if (clear === void 0) {
        clear = false;
      }
      var conf = {
        values: clear ? alts.values : _extends({}, dur.values, alts.values || {}),
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy
      };
      return new Duration(conf);
    }
    function antiTrunc(n2) {
      return n2 < 0 ? Math.floor(n2) : Math.ceil(n2);
    }
    function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
      var conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
      toMap[toUnit] += added;
      fromMap[fromUnit] -= added * conv;
    }
    function normalizeValues(matrix, vals) {
      reverseUnits.reduce(function(previous, current) {
        if (!isUndefined(vals[current])) {
          if (previous) {
            convert(matrix, vals, previous, vals, current);
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    var Duration = /* @__PURE__ */ function() {
      function Duration2(config) {
        var accurate = config.conversionAccuracy === "longterm" || false;
        this.values = config.values;
        this.loc = config.loc || Locale.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config.invalid || null;
        this.matrix = accurate ? accurateMatrix : casualMatrix;
        this.isLuxonDuration = true;
      }
      Duration2.fromMillis = function fromMillis(count, opts) {
        return Duration2.fromObject({
          milliseconds: count
        }, opts);
      };
      Duration2.fromObject = function fromObject(obj, opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError("Duration.fromObject: argument expected to be an object, got " + (obj === null ? "null" : typeof obj));
        }
        return new Duration2({
          values: normalizeObject(obj, Duration2.normalizeUnit),
          loc: Locale.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy
        });
      };
      Duration2.fromDurationLike = function fromDurationLike(durationLike) {
        if (isNumber(durationLike)) {
          return Duration2.fromMillis(durationLike);
        } else if (Duration2.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return Duration2.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError("Unknown duration argument " + durationLike + " of type " + typeof durationLike);
        }
      };
      Duration2.fromISO = function fromISO(text, opts) {
        var _parseISODuration = parseISODuration(text), parsed = _parseISODuration[0];
        if (parsed) {
          return Duration2.fromObject(parsed, opts);
        } else {
          return Duration2.invalid("unparsable", 'the input "' + text + `" can't be parsed as ISO 8601`);
        }
      };
      Duration2.fromISOTime = function fromISOTime(text, opts) {
        var _parseISOTimeOnly = parseISOTimeOnly(text), parsed = _parseISOTimeOnly[0];
        if (parsed) {
          return Duration2.fromObject(parsed, opts);
        } else {
          return Duration2.invalid("unparsable", 'the input "' + text + `" can't be parsed as ISO 8601`);
        }
      };
      Duration2.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
        }
        var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDurationError(invalid2);
        } else {
          return new Duration2({
            invalid: invalid2
          });
        }
      };
      Duration2.normalizeUnit = function normalizeUnit2(unit) {
        var normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized)
          throw new InvalidUnitError(unit);
        return normalized;
      };
      Duration2.isDuration = function isDuration(o) {
        return o && o.isLuxonDuration || false;
      };
      var _proto = Duration2.prototype;
      _proto.toFormat = function toFormat(fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var fmtOpts = _extends({}, opts, {
          floor: opts.round !== false && opts.floor !== false
        });
        return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
      };
      _proto.toHuman = function toHuman(opts) {
        var _this = this;
        if (opts === void 0) {
          opts = {};
        }
        var l2 = orderedUnits$1.map(function(unit) {
          var val = _this.values[unit];
          if (isUndefined(val)) {
            return null;
          }
          return _this.loc.numberFormatter(_extends({
            style: "unit",
            unitDisplay: "long"
          }, opts, {
            unit: unit.slice(0, -1)
          })).format(val);
        }).filter(function(n2) {
          return n2;
        });
        return this.loc.listFormatter(_extends({
          type: "conjunction",
          style: opts.listStyle || "narrow"
        }, opts)).format(l2);
      };
      _proto.toObject = function toObject() {
        if (!this.isValid)
          return {};
        return _extends({}, this.values);
      };
      _proto.toISO = function toISO() {
        if (!this.isValid)
          return null;
        var s2 = "P";
        if (this.years !== 0)
          s2 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0)
          s2 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0)
          s2 += this.weeks + "W";
        if (this.days !== 0)
          s2 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
          s2 += "T";
        if (this.hours !== 0)
          s2 += this.hours + "H";
        if (this.minutes !== 0)
          s2 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s2 === "P")
          s2 += "T0S";
        return s2;
      };
      _proto.toISOTime = function toISOTime(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid)
          return null;
        var millis = this.toMillis();
        if (millis < 0 || millis >= 864e5)
          return null;
        opts = _extends({
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended"
        }, opts);
        var value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
        var fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
        if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
          fmt += opts.format === "basic" ? "ss" : ":ss";
          if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
            fmt += ".SSS";
          }
        }
        var str = value.toFormat(fmt);
        if (opts.includePrefix) {
          str = "T" + str;
        }
        return str;
      };
      _proto.toJSON = function toJSON() {
        return this.toISO();
      };
      _proto.toString = function toString() {
        return this.toISO();
      };
      _proto.toMillis = function toMillis() {
        return this.as("milliseconds");
      };
      _proto.valueOf = function valueOf() {
        return this.toMillis();
      };
      _proto.plus = function plus(duration) {
        if (!this.isValid)
          return this;
        var dur = Duration2.fromDurationLike(duration), result = {};
        for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits$1), _step; !(_step = _iterator()).done; ) {
          var k = _step.value;
          if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
            result[k] = dur.get(k) + this.get(k);
          }
        }
        return clone$1(this, {
          values: result
        }, true);
      };
      _proto.minus = function minus(duration) {
        if (!this.isValid)
          return this;
        var dur = Duration2.fromDurationLike(duration);
        return this.plus(dur.negate());
      };
      _proto.mapUnits = function mapUnits(fn) {
        if (!this.isValid)
          return this;
        var result = {};
        for (var _i = 0, _Object$keys = Object.keys(this.values); _i < _Object$keys.length; _i++) {
          var k = _Object$keys[_i];
          result[k] = asNumber(fn(this.values[k], k));
        }
        return clone$1(this, {
          values: result
        }, true);
      };
      _proto.get = function get(unit) {
        return this[Duration2.normalizeUnit(unit)];
      };
      _proto.set = function set(values) {
        if (!this.isValid)
          return this;
        var mixed = _extends({}, this.values, normalizeObject(values, Duration2.normalizeUnit));
        return clone$1(this, {
          values: mixed
        });
      };
      _proto.reconfigure = function reconfigure(_temp) {
        var _ref = _temp === void 0 ? {} : _temp, locale = _ref.locale, numberingSystem = _ref.numberingSystem, conversionAccuracy = _ref.conversionAccuracy;
        var loc = this.loc.clone({
          locale,
          numberingSystem
        }), opts = {
          loc
        };
        if (conversionAccuracy) {
          opts.conversionAccuracy = conversionAccuracy;
        }
        return clone$1(this, opts);
      };
      _proto.as = function as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      };
      _proto.normalize = function normalize() {
        if (!this.isValid)
          return this;
        var vals = this.toObject();
        normalizeValues(this.matrix, vals);
        return clone$1(this, {
          values: vals
        }, true);
      };
      _proto.shiftTo = function shiftTo() {
        for (var _len = arguments.length, units = new Array(_len), _key = 0; _key < _len; _key++) {
          units[_key] = arguments[_key];
        }
        if (!this.isValid)
          return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map(function(u) {
          return Duration2.normalizeUnit(u);
        });
        var built = {}, accumulated = {}, vals = this.toObject();
        var lastUnit;
        for (var _iterator2 = _createForOfIteratorHelperLoose(orderedUnits$1), _step2; !(_step2 = _iterator2()).done; ) {
          var k = _step2.value;
          if (units.indexOf(k) >= 0) {
            lastUnit = k;
            var own = 0;
            for (var ak in accumulated) {
              own += this.matrix[ak][k] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber(vals[k])) {
              own += vals[k];
            }
            var i = Math.trunc(own);
            built[k] = i;
            accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
            for (var down in vals) {
              if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k)) {
                convert(this.matrix, vals, down, built, k);
              }
            }
          } else if (isNumber(vals[k])) {
            accumulated[k] = vals[k];
          }
        }
        for (var key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        return clone$1(this, {
          values: built
        }, true).normalize();
      };
      _proto.negate = function negate() {
        if (!this.isValid)
          return this;
        var negated = {};
        for (var _i2 = 0, _Object$keys2 = Object.keys(this.values); _i2 < _Object$keys2.length; _i2++) {
          var k = _Object$keys2[_i2];
          negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
        }
        return clone$1(this, {
          values: negated
        }, true);
      };
      _proto.equals = function equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq(v1, v2) {
          if (v1 === void 0 || v1 === 0)
            return v2 === void 0 || v2 === 0;
          return v1 === v2;
        }
        for (var _iterator3 = _createForOfIteratorHelperLoose(orderedUnits$1), _step3; !(_step3 = _iterator3()).done; ) {
          var u = _step3.value;
          if (!eq(this.values[u], other.values[u])) {
            return false;
          }
        }
        return true;
      };
      _createClass(Duration2, [{
        key: "locale",
        get: function get() {
          return this.isValid ? this.loc.locale : null;
        }
      }, {
        key: "numberingSystem",
        get: function get() {
          return this.isValid ? this.loc.numberingSystem : null;
        }
      }, {
        key: "years",
        get: function get() {
          return this.isValid ? this.values.years || 0 : NaN;
        }
      }, {
        key: "quarters",
        get: function get() {
          return this.isValid ? this.values.quarters || 0 : NaN;
        }
      }, {
        key: "months",
        get: function get() {
          return this.isValid ? this.values.months || 0 : NaN;
        }
      }, {
        key: "weeks",
        get: function get() {
          return this.isValid ? this.values.weeks || 0 : NaN;
        }
      }, {
        key: "days",
        get: function get() {
          return this.isValid ? this.values.days || 0 : NaN;
        }
      }, {
        key: "hours",
        get: function get() {
          return this.isValid ? this.values.hours || 0 : NaN;
        }
      }, {
        key: "minutes",
        get: function get() {
          return this.isValid ? this.values.minutes || 0 : NaN;
        }
      }, {
        key: "seconds",
        get: function get() {
          return this.isValid ? this.values.seconds || 0 : NaN;
        }
      }, {
        key: "milliseconds",
        get: function get() {
          return this.isValid ? this.values.milliseconds || 0 : NaN;
        }
      }, {
        key: "isValid",
        get: function get() {
          return this.invalid === null;
        }
      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
      }]);
      return Duration2;
    }();
    var INVALID$1 = "Invalid Interval";
    function validateStartEnd(start, end) {
      if (!start || !start.isValid) {
        return Interval.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval.invalid("end before start", "The end of an interval must be after its start, but you had start=" + start.toISO() + " and end=" + end.toISO());
      } else {
        return null;
      }
    }
    var Interval = /* @__PURE__ */ function() {
      function Interval2(config) {
        this.s = config.start;
        this.e = config.end;
        this.invalid = config.invalid || null;
        this.isLuxonInterval = true;
      }
      Interval2.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
        }
        var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidIntervalError(invalid2);
        } else {
          return new Interval2({
            invalid: invalid2
          });
        }
      };
      Interval2.fromDateTimes = function fromDateTimes(start, end) {
        var builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
        var validateError = validateStartEnd(builtStart, builtEnd);
        if (validateError == null) {
          return new Interval2({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      };
      Interval2.after = function after(start, duration) {
        var dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
        return Interval2.fromDateTimes(dt, dt.plus(dur));
      };
      Interval2.before = function before(end, duration) {
        var dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
        return Interval2.fromDateTimes(dt.minus(dur), dt);
      };
      Interval2.fromISO = function fromISO(text, opts) {
        var _split = (text || "").split("/", 2), s2 = _split[0], e = _split[1];
        if (s2 && e) {
          var start, startIsValid;
          try {
            start = DateTime.fromISO(s2, opts);
            startIsValid = start.isValid;
          } catch (e2) {
            startIsValid = false;
          }
          var end, endIsValid;
          try {
            end = DateTime.fromISO(e, opts);
            endIsValid = end.isValid;
          } catch (e2) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return Interval2.fromDateTimes(start, end);
          }
          if (startIsValid) {
            var dur = Duration.fromISO(e, opts);
            if (dur.isValid) {
              return Interval2.after(start, dur);
            }
          } else if (endIsValid) {
            var _dur = Duration.fromISO(s2, opts);
            if (_dur.isValid) {
              return Interval2.before(end, _dur);
            }
          }
        }
        return Interval2.invalid("unparsable", 'the input "' + text + `" can't be parsed as ISO 8601`);
      };
      Interval2.isInterval = function isInterval(o) {
        return o && o.isLuxonInterval || false;
      };
      var _proto = Interval2.prototype;
      _proto.length = function length(unit) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        return this.isValid ? this.toDuration.apply(this, [unit]).get(unit) : NaN;
      };
      _proto.count = function count(unit) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        if (!this.isValid)
          return NaN;
        var start = this.start.startOf(unit), end = this.end.startOf(unit);
        return Math.floor(end.diff(start, unit).get(unit)) + 1;
      };
      _proto.hasSame = function hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      };
      _proto.isEmpty = function isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      };
      _proto.isAfter = function isAfter(dateTime) {
        if (!this.isValid)
          return false;
        return this.s > dateTime;
      };
      _proto.isBefore = function isBefore(dateTime) {
        if (!this.isValid)
          return false;
        return this.e <= dateTime;
      };
      _proto.contains = function contains(dateTime) {
        if (!this.isValid)
          return false;
        return this.s <= dateTime && this.e > dateTime;
      };
      _proto.set = function set(_temp) {
        var _ref = _temp === void 0 ? {} : _temp, start = _ref.start, end = _ref.end;
        if (!this.isValid)
          return this;
        return Interval2.fromDateTimes(start || this.s, end || this.e);
      };
      _proto.splitAt = function splitAt() {
        var _this = this;
        if (!this.isValid)
          return [];
        for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
          dateTimes[_key] = arguments[_key];
        }
        var sorted = dateTimes.map(friendlyDateTime).filter(function(d) {
          return _this.contains(d);
        }).sort(), results = [];
        var s2 = this.s, i = 0;
        while (s2 < this.e) {
          var added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
          results.push(Interval2.fromDateTimes(s2, next));
          s2 = next;
          i += 1;
        }
        return results;
      };
      _proto.splitBy = function splitBy(duration) {
        var dur = Duration.fromDurationLike(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        var s2 = this.s, idx = 1, next;
        var results = [];
        while (s2 < this.e) {
          var added = this.start.plus(dur.mapUnits(function(x) {
            return x * idx;
          }));
          next = +added > +this.e ? this.e : added;
          results.push(Interval2.fromDateTimes(s2, next));
          s2 = next;
          idx += 1;
        }
        return results;
      };
      _proto.divideEqually = function divideEqually(numberOfParts) {
        if (!this.isValid)
          return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      };
      _proto.overlaps = function overlaps(other) {
        return this.e > other.s && this.s < other.e;
      };
      _proto.abutsStart = function abutsStart(other) {
        if (!this.isValid)
          return false;
        return +this.e === +other.s;
      };
      _proto.abutsEnd = function abutsEnd(other) {
        if (!this.isValid)
          return false;
        return +other.e === +this.s;
      };
      _proto.engulfs = function engulfs(other) {
        if (!this.isValid)
          return false;
        return this.s <= other.s && this.e >= other.e;
      };
      _proto.equals = function equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      };
      _proto.intersection = function intersection(other) {
        if (!this.isValid)
          return this;
        var s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
        if (s2 >= e) {
          return null;
        } else {
          return Interval2.fromDateTimes(s2, e);
        }
      };
      _proto.union = function union(other) {
        if (!this.isValid)
          return this;
        var s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
        return Interval2.fromDateTimes(s2, e);
      };
      Interval2.merge = function merge(intervals) {
        var _intervals$sort$reduc = intervals.sort(function(a, b) {
          return a.s - b.s;
        }).reduce(function(_ref2, item) {
          var sofar = _ref2[0], current = _ref2[1];
          if (!current) {
            return [sofar, item];
          } else if (current.overlaps(item) || current.abutsStart(item)) {
            return [sofar, current.union(item)];
          } else {
            return [sofar.concat([current]), item];
          }
        }, [[], null]), found = _intervals$sort$reduc[0], final = _intervals$sort$reduc[1];
        if (final) {
          found.push(final);
        }
        return found;
      };
      Interval2.xor = function xor(intervals) {
        var _Array$prototype;
        var start = null, currentCount = 0;
        var results = [], ends = intervals.map(function(i2) {
          return [{
            time: i2.s,
            type: "s"
          }, {
            time: i2.e,
            type: "e"
          }];
        }), flattened = (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, ends), arr = flattened.sort(function(a, b) {
          return a.time - b.time;
        });
        for (var _iterator = _createForOfIteratorHelperLoose(arr), _step; !(_step = _iterator()).done; ) {
          var i = _step.value;
          currentCount += i.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start = i.time;
          } else {
            if (start && +start !== +i.time) {
              results.push(Interval2.fromDateTimes(start, i.time));
            }
            start = null;
          }
        }
        return Interval2.merge(results);
      };
      _proto.difference = function difference() {
        var _this2 = this;
        for (var _len2 = arguments.length, intervals = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          intervals[_key2] = arguments[_key2];
        }
        return Interval2.xor([this].concat(intervals)).map(function(i) {
          return _this2.intersection(i);
        }).filter(function(i) {
          return i && !i.isEmpty();
        });
      };
      _proto.toString = function toString() {
        if (!this.isValid)
          return INVALID$1;
        return "[" + this.s.toISO() + " \u2013 " + this.e.toISO() + ")";
      };
      _proto.toISO = function toISO(opts) {
        if (!this.isValid)
          return INVALID$1;
        return this.s.toISO(opts) + "/" + this.e.toISO(opts);
      };
      _proto.toISODate = function toISODate() {
        if (!this.isValid)
          return INVALID$1;
        return this.s.toISODate() + "/" + this.e.toISODate();
      };
      _proto.toISOTime = function toISOTime(opts) {
        if (!this.isValid)
          return INVALID$1;
        return this.s.toISOTime(opts) + "/" + this.e.toISOTime(opts);
      };
      _proto.toFormat = function toFormat(dateFormat, _temp2) {
        var _ref3 = _temp2 === void 0 ? {} : _temp2, _ref3$separator = _ref3.separator, separator = _ref3$separator === void 0 ? " \u2013 " : _ref3$separator;
        if (!this.isValid)
          return INVALID$1;
        return "" + this.s.toFormat(dateFormat) + separator + this.e.toFormat(dateFormat);
      };
      _proto.toDuration = function toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      };
      _proto.mapEndpoints = function mapEndpoints(mapFn) {
        return Interval2.fromDateTimes(mapFn(this.s), mapFn(this.e));
      };
      _createClass(Interval2, [{
        key: "start",
        get: function get() {
          return this.isValid ? this.s : null;
        }
      }, {
        key: "end",
        get: function get() {
          return this.isValid ? this.e : null;
        }
      }, {
        key: "isValid",
        get: function get() {
          return this.invalidReason === null;
        }
      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
      }]);
      return Interval2;
    }();
    var Info = /* @__PURE__ */ function() {
      function Info2() {
      }
      Info2.hasDST = function hasDST(zone) {
        if (zone === void 0) {
          zone = Settings.defaultZone;
        }
        var proto = DateTime.now().setZone(zone).set({
          month: 12
        });
        return !zone.isUniversal && proto.offset !== proto.set({
          month: 6
        }).offset;
      };
      Info2.isValidIANAZone = function isValidIANAZone(zone) {
        return IANAZone.isValidZone(zone);
      };
      Info2.normalizeZone = function normalizeZone$1(input) {
        return normalizeZone(input, Settings.defaultZone);
      };
      Info2.months = function months2(length, _temp) {
        if (length === void 0) {
          length = "long";
        }
        var _ref = _temp === void 0 ? {} : _temp, _ref$locale = _ref.locale, locale = _ref$locale === void 0 ? null : _ref$locale, _ref$numberingSystem = _ref.numberingSystem, numberingSystem = _ref$numberingSystem === void 0 ? null : _ref$numberingSystem, _ref$locObj = _ref.locObj, locObj = _ref$locObj === void 0 ? null : _ref$locObj, _ref$outputCalendar = _ref.outputCalendar, outputCalendar = _ref$outputCalendar === void 0 ? "gregory" : _ref$outputCalendar;
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
      };
      Info2.monthsFormat = function monthsFormat(length, _temp2) {
        if (length === void 0) {
          length = "long";
        }
        var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$locale = _ref2.locale, locale = _ref2$locale === void 0 ? null : _ref2$locale, _ref2$numberingSystem = _ref2.numberingSystem, numberingSystem = _ref2$numberingSystem === void 0 ? null : _ref2$numberingSystem, _ref2$locObj = _ref2.locObj, locObj = _ref2$locObj === void 0 ? null : _ref2$locObj, _ref2$outputCalendar = _ref2.outputCalendar, outputCalendar = _ref2$outputCalendar === void 0 ? "gregory" : _ref2$outputCalendar;
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
      };
      Info2.weekdays = function weekdays2(length, _temp3) {
        if (length === void 0) {
          length = "long";
        }
        var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$locale = _ref3.locale, locale = _ref3$locale === void 0 ? null : _ref3$locale, _ref3$numberingSystem = _ref3.numberingSystem, numberingSystem = _ref3$numberingSystem === void 0 ? null : _ref3$numberingSystem, _ref3$locObj = _ref3.locObj, locObj = _ref3$locObj === void 0 ? null : _ref3$locObj;
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
      };
      Info2.weekdaysFormat = function weekdaysFormat(length, _temp4) {
        if (length === void 0) {
          length = "long";
        }
        var _ref4 = _temp4 === void 0 ? {} : _temp4, _ref4$locale = _ref4.locale, locale = _ref4$locale === void 0 ? null : _ref4$locale, _ref4$numberingSystem = _ref4.numberingSystem, numberingSystem = _ref4$numberingSystem === void 0 ? null : _ref4$numberingSystem, _ref4$locObj = _ref4.locObj, locObj = _ref4$locObj === void 0 ? null : _ref4$locObj;
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
      };
      Info2.meridiems = function meridiems2(_temp5) {
        var _ref5 = _temp5 === void 0 ? {} : _temp5, _ref5$locale = _ref5.locale, locale = _ref5$locale === void 0 ? null : _ref5$locale;
        return Locale.create(locale).meridiems();
      };
      Info2.eras = function eras2(length, _temp6) {
        if (length === void 0) {
          length = "short";
        }
        var _ref6 = _temp6 === void 0 ? {} : _temp6, _ref6$locale = _ref6.locale, locale = _ref6$locale === void 0 ? null : _ref6$locale;
        return Locale.create(locale, null, "gregory").eras(length);
      };
      Info2.features = function features() {
        return {
          relative: hasRelative()
        };
      };
      return Info2;
    }();
    function dayDiff(earlier, later) {
      var utcDayStart = function utcDayStart2(dt) {
        return dt.toUTC(0, {
          keepLocalTime: true
        }).startOf("day").valueOf();
      }, ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration.fromMillis(ms).as("days"));
    }
    function highOrderDiffs(cursor, later, units) {
      var differs = [["years", function(a, b) {
        return b.year - a.year;
      }], ["quarters", function(a, b) {
        return b.quarter - a.quarter;
      }], ["months", function(a, b) {
        return b.month - a.month + (b.year - a.year) * 12;
      }], ["weeks", function(a, b) {
        var days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }], ["days", dayDiff]];
      var results = {};
      var lowestOrder, highWater;
      for (var _i = 0, _differs = differs; _i < _differs.length; _i++) {
        var _differs$_i = _differs[_i], unit = _differs$_i[0], differ = _differs$_i[1];
        if (units.indexOf(unit) >= 0) {
          var _cursor$plus;
          lowestOrder = unit;
          var delta = differ(cursor, later);
          highWater = cursor.plus((_cursor$plus = {}, _cursor$plus[unit] = delta, _cursor$plus));
          if (highWater > later) {
            var _cursor$plus2;
            cursor = cursor.plus((_cursor$plus2 = {}, _cursor$plus2[unit] = delta - 1, _cursor$plus2));
            delta -= 1;
          } else {
            cursor = highWater;
          }
          results[unit] = delta;
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function _diff(earlier, later, units, opts) {
      var _highOrderDiffs = highOrderDiffs(earlier, later, units), cursor = _highOrderDiffs[0], results = _highOrderDiffs[1], highWater = _highOrderDiffs[2], lowestOrder = _highOrderDiffs[3];
      var remainingMillis = later - cursor;
      var lowerOrderUnits = units.filter(function(u) {
        return ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0;
      });
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          var _cursor$plus3;
          highWater = cursor.plus((_cursor$plus3 = {}, _cursor$plus3[lowestOrder] = 1, _cursor$plus3));
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      var duration = Duration.fromObject(results, opts);
      if (lowerOrderUnits.length > 0) {
        var _Duration$fromMillis;
        return (_Duration$fromMillis = Duration.fromMillis(remainingMillis, opts)).shiftTo.apply(_Duration$fromMillis, lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var numberingSystems = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF16 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits(str) {
      var value = parseInt(str, 10);
      if (isNaN(value)) {
        value = "";
        for (var i = 0; i < str.length; i++) {
          var code = str.charCodeAt(i);
          if (str[i].search(numberingSystems.hanidec) !== -1) {
            value += hanidecChars.indexOf(str[i]);
          } else {
            for (var key in numberingSystemsUTF16) {
              var _numberingSystemsUTF = numberingSystemsUTF16[key], min = _numberingSystemsUTF[0], max = _numberingSystemsUTF[1];
              if (code >= min && code <= max) {
                value += code - min;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex(_ref, append) {
      var numberingSystem = _ref.numberingSystem;
      if (append === void 0) {
        append = "";
      }
      return new RegExp("" + numberingSystems[numberingSystem || "latn"] + append);
    }
    var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit(regex, post) {
      if (post === void 0) {
        post = function post2(i) {
          return i;
        };
      }
      return {
        regex,
        deser: function deser(_ref) {
          var s2 = _ref[0];
          return post(parseDigits(s2));
        }
      };
    }
    var NBSP = String.fromCharCode(160);
    var spaceOrNBSP = "[ " + NBSP + "]";
    var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
    function fixListRegex(s2) {
      return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
    }
    function stripInsensitivities(s2) {
      return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
    }
    function oneOf(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex).join("|")),
          deser: function deser(_ref2) {
            var s2 = _ref2[0];
            return strings.findIndex(function(i) {
              return stripInsensitivities(s2) === stripInsensitivities(i);
            }) + startIndex;
          }
        };
      }
    }
    function offset(regex, groups) {
      return {
        regex,
        deser: function deser(_ref3) {
          var h = _ref3[1], m = _ref3[2];
          return signedOffset(h, m);
        },
        groups
      };
    }
    function simple(regex) {
      return {
        regex,
        deser: function deser(_ref4) {
          var s2 = _ref4[0];
          return s2;
        }
      };
    }
    function escapeToken(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken(token, loc) {
      var one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = function literal2(t) {
        return {
          regex: RegExp(escapeToken(t.val)),
          deser: function deser(_ref5) {
            var s2 = _ref5[0];
            return s2;
          },
          literal: true
        };
      }, unitate = function unitate2(t) {
        if (token.literal) {
          return literal(t);
        }
        switch (t.val) {
          case "G":
            return oneOf(loc.eras("short", false), 0);
          case "GG":
            return oneOf(loc.eras("long", false), 0);
          case "y":
            return intUnit(oneToSix);
          case "yy":
            return intUnit(twoToFour, untruncateYear);
          case "yyyy":
            return intUnit(four);
          case "yyyyy":
            return intUnit(fourToSix);
          case "yyyyyy":
            return intUnit(six);
          case "M":
            return intUnit(oneOrTwo);
          case "MM":
            return intUnit(two);
          case "MMM":
            return oneOf(loc.months("short", true, false), 1);
          case "MMMM":
            return oneOf(loc.months("long", true, false), 1);
          case "L":
            return intUnit(oneOrTwo);
          case "LL":
            return intUnit(two);
          case "LLL":
            return oneOf(loc.months("short", false, false), 1);
          case "LLLL":
            return oneOf(loc.months("long", false, false), 1);
          case "d":
            return intUnit(oneOrTwo);
          case "dd":
            return intUnit(two);
          case "o":
            return intUnit(oneToThree);
          case "ooo":
            return intUnit(three);
          case "HH":
            return intUnit(two);
          case "H":
            return intUnit(oneOrTwo);
          case "hh":
            return intUnit(two);
          case "h":
            return intUnit(oneOrTwo);
          case "mm":
            return intUnit(two);
          case "m":
            return intUnit(oneOrTwo);
          case "q":
            return intUnit(oneOrTwo);
          case "qq":
            return intUnit(two);
          case "s":
            return intUnit(oneOrTwo);
          case "ss":
            return intUnit(two);
          case "S":
            return intUnit(oneToThree);
          case "SSS":
            return intUnit(three);
          case "u":
            return simple(oneToNine);
          case "uu":
            return simple(oneOrTwo);
          case "uuu":
            return intUnit(one);
          case "a":
            return oneOf(loc.meridiems(), 0);
          case "kkkk":
            return intUnit(four);
          case "kk":
            return intUnit(twoToFour, untruncateYear);
          case "W":
            return intUnit(oneOrTwo);
          case "WW":
            return intUnit(two);
          case "E":
          case "c":
            return intUnit(one);
          case "EEE":
            return oneOf(loc.weekdays("short", false, false), 1);
          case "EEEE":
            return oneOf(loc.weekdays("long", false, false), 1);
          case "ccc":
            return oneOf(loc.weekdays("short", true, false), 1);
          case "cccc":
            return oneOf(loc.weekdays("long", true, false), 1);
          case "Z":
          case "ZZ":
            return offset(new RegExp("([+-]" + oneOrTwo.source + ")(?::(" + two.source + "))?"), 2);
          case "ZZZ":
            return offset(new RegExp("([+-]" + oneOrTwo.source + ")(" + two.source + ")?"), 2);
          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
          default:
            return literal(t);
        }
      };
      var unit = unitate(token) || {
        invalidReason: MISSING_FTP
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour: {
        numeric: "h",
        "2-digit": "hh"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      }
    };
    function tokenForPart(part, locale, formatOpts) {
      var type = part.type, value = part.value;
      if (type === "literal") {
        return {
          literal: true,
          val: value
        };
      }
      var style = formatOpts[type];
      var val = partTypeStyleToTokenVal[type];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex(units) {
      var re = units.map(function(u) {
        return u.regex;
      }).reduce(function(f, r) {
        return f + "(" + r.source + ")";
      }, "");
      return ["^" + re + "$", units];
    }
    function match(input, regex, handlers) {
      var matches = input.match(regex);
      if (matches) {
        var all = {};
        var matchIndex = 1;
        for (var i in handlers) {
          if (hasOwnProperty(handlers, i)) {
            var h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
            if (!h.literal && h.token) {
              all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches, all];
      } else {
        return [matches, {}];
      }
    }
    function dateTimeFromMatches(matches) {
      var toField = function toField2(token) {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      var zone = null;
      var specificOffset;
      if (!isUndefined(matches.z)) {
        zone = IANAZone.create(matches.z);
      }
      if (!isUndefined(matches.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone(matches.Z);
        }
        specificOffset = matches.Z;
      }
      if (!isUndefined(matches.q)) {
        matches.M = (matches.q - 1) * 3 + 1;
      }
      if (!isUndefined(matches.h)) {
        if (matches.h < 12 && matches.a === 1) {
          matches.h += 12;
        } else if (matches.h === 12 && matches.a === 0) {
          matches.h = 0;
        }
      }
      if (matches.G === 0 && matches.y) {
        matches.y = -matches.y;
      }
      if (!isUndefined(matches.u)) {
        matches.S = parseMillis(matches.u);
      }
      var vals = Object.keys(matches).reduce(function(r, k) {
        var f = toField(k);
        if (f) {
          r[f] = matches[k];
        }
        return r;
      }, {});
      return [vals, zone, specificOffset];
    }
    var dummyDateTimeCache = null;
    function getDummyDateTime() {
      if (!dummyDateTimeCache) {
        dummyDateTimeCache = DateTime.fromMillis(1555555555555);
      }
      return dummyDateTimeCache;
    }
    function maybeExpandMacroToken(token, locale) {
      if (token.literal) {
        return token;
      }
      var formatOpts = Formatter.macroTokenToFormatOpts(token.val);
      if (!formatOpts) {
        return token;
      }
      var formatter = Formatter.create(locale, formatOpts);
      var parts = formatter.formatDateTimeParts(getDummyDateTime());
      var tokens = parts.map(function(p) {
        return tokenForPart(p, locale, formatOpts);
      });
      if (tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens(tokens, locale) {
      var _Array$prototype;
      return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, tokens.map(function(t) {
        return maybeExpandMacroToken(t, locale);
      }));
    }
    function explainFromTokens(locale, input, format) {
      var tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map(function(t) {
        return unitForToken(t, locale);
      }), disqualifyingUnit = units.find(function(t) {
        return t.invalidReason;
      });
      if (disqualifyingUnit) {
        return {
          input,
          tokens,
          invalidReason: disqualifyingUnit.invalidReason
        };
      } else {
        var _buildRegex = buildRegex(units), regexString = _buildRegex[0], handlers = _buildRegex[1], regex = RegExp(regexString, "i"), _match = match(input, regex, handlers), rawMatches = _match[0], matches = _match[1], _ref6 = matches ? dateTimeFromMatches(matches) : [null, null, void 0], result = _ref6[0], zone = _ref6[1], specificOffset = _ref6[2];
        if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
          throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
        }
        return {
          input,
          tokens,
          regex,
          rawMatches,
          matches,
          result,
          zone,
          specificOffset
        };
      }
    }
    function parseFromTokens(locale, input, format) {
      var _explainFromTokens = explainFromTokens(locale, input, format), result = _explainFromTokens.result, zone = _explainFromTokens.zone, specificOffset = _explainFromTokens.specificOffset, invalidReason = _explainFromTokens.invalidReason;
      return [result, zone, specificOffset, invalidReason];
    }
    var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange(unit, value) {
      return new Invalid("unit out of range", "you specified " + value + " (of type " + typeof value + ") as a " + unit + ", which is invalid");
    }
    function dayOfWeek(year, month, day) {
      var d = new Date(Date.UTC(year, month - 1, day));
      if (year < 100 && year >= 0) {
        d.setUTCFullYear(d.getUTCFullYear() - 1900);
      }
      var js = d.getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal(year, month, day) {
      return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
    }
    function uncomputeOrdinal(year, ordinal) {
      var table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex(function(i) {
        return i < ordinal;
      }), day = ordinal - table[month0];
      return {
        month: month0 + 1,
        day
      };
    }
    function gregorianToWeek(gregObj) {
      var year = gregObj.year, month = gregObj.month, day = gregObj.day, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
      var weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear(weekYear);
      } else if (weekNumber > weeksInWeekYear(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return _extends({
        weekYear,
        weekNumber,
        weekday
      }, timeObject(gregObj));
    }
    function weekToGregorian(weekData) {
      var weekYear = weekData.weekYear, weekNumber = weekData.weekNumber, weekday = weekData.weekday, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
      var ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear(weekYear);
      } else {
        year = weekYear;
      }
      var _uncomputeOrdinal = uncomputeOrdinal(year, ordinal), month = _uncomputeOrdinal.month, day = _uncomputeOrdinal.day;
      return _extends({
        year,
        month,
        day
      }, timeObject(weekData));
    }
    function gregorianToOrdinal(gregData) {
      var year = gregData.year, month = gregData.month, day = gregData.day;
      var ordinal = computeOrdinal(year, month, day);
      return _extends({
        year,
        ordinal
      }, timeObject(gregData));
    }
    function ordinalToGregorian(ordinalData) {
      var year = ordinalData.year, ordinal = ordinalData.ordinal;
      var _uncomputeOrdinal2 = uncomputeOrdinal(year, ordinal), month = _uncomputeOrdinal2.month, day = _uncomputeOrdinal2.day;
      return _extends({
        year,
        month,
        day
      }, timeObject(ordinalData));
    }
    function hasInvalidWeekData(obj) {
      var validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange("weekday", obj.weekday);
      } else
        return false;
    }
    function hasInvalidOrdinalData(obj) {
      var validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange("ordinal", obj.ordinal);
      } else
        return false;
    }
    function hasInvalidGregorianData(obj) {
      var validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange("day", obj.day);
      } else
        return false;
    }
    function hasInvalidTimeData(obj) {
      var hour = obj.hour, minute = obj.minute, second = obj.second, millisecond = obj.millisecond;
      var validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange("millisecond", millisecond);
      } else
        return false;
    }
    var INVALID = "Invalid DateTime";
    var MAX_DATE = 864e13;
    function unsupportedZone(zone) {
      return new Invalid("unsupported zone", 'the zone "' + zone.name + '" is not supported');
    }
    function possiblyCachedWeekData(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek(dt.c);
      }
      return dt.weekData;
    }
    function clone(inst, alts) {
      var current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime(_extends({}, current, alts, {
        old: current
      }));
    }
    function fixOffset(localTS, o, tz) {
      var utcGuess = localTS - o * 60 * 1e3;
      var o2 = tz.offset(utcGuess);
      if (o === o2) {
        return [utcGuess, o];
      }
      utcGuess -= (o2 - o) * 60 * 1e3;
      var o3 = tz.offset(utcGuess);
      if (o2 === o3) {
        return [utcGuess, o2];
      }
      return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
    }
    function tsToObj(ts, offset2) {
      ts += offset2 * 60 * 1e3;
      var d = new Date(ts);
      return {
        year: d.getUTCFullYear(),
        month: d.getUTCMonth() + 1,
        day: d.getUTCDate(),
        hour: d.getUTCHours(),
        minute: d.getUTCMinutes(),
        second: d.getUTCSeconds(),
        millisecond: d.getUTCMilliseconds()
      };
    }
    function objToTS(obj, offset2, zone) {
      return fixOffset(objToLocalTS(obj), offset2, zone);
    }
    function adjustTime(inst, dur) {
      var oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = _extends({}, inst.c, {
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }), millisToAdd = Duration.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS(c);
      var _fixOffset = fixOffset(localTS, oPre, inst.zone), ts = _fixOffset[0], o = _fixOffset[1];
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o = inst.zone.offset(ts);
      }
      return {
        ts,
        o
      };
    }
    function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
      var setZone = opts.setZone, zone = opts.zone;
      if (parsed && Object.keys(parsed).length !== 0) {
        var interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, _extends({}, opts, {
          zone: interpretationZone,
          specificOffset
        }));
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime.invalid(new Invalid("unparsable", 'the input "' + text + `" can't be parsed as ` + format));
      }
    }
    function toTechFormat(dt, format, allowZ) {
      if (allowZ === void 0) {
        allowZ = true;
      }
      return dt.isValid ? Formatter.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format) : null;
    }
    function _toISODate(o, extended) {
      var longFormat = o.c.year > 9999 || o.c.year < 0;
      var c = "";
      if (longFormat && o.c.year >= 0)
        c += "+";
      c += padStart(o.c.year, longFormat ? 6 : 4);
      if (extended) {
        c += "-";
        c += padStart(o.c.month);
        c += "-";
        c += padStart(o.c.day);
      } else {
        c += padStart(o.c.month);
        c += padStart(o.c.day);
      }
      return c;
    }
    function _toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
      var c = padStart(o.c.hour);
      if (extended) {
        c += ":";
        c += padStart(o.c.minute);
        if (o.c.second !== 0 || !suppressSeconds) {
          c += ":";
        }
      } else {
        c += padStart(o.c.minute);
      }
      if (o.c.second !== 0 || !suppressSeconds) {
        c += padStart(o.c.second);
        if (o.c.millisecond !== 0 || !suppressMilliseconds) {
          c += ".";
          c += padStart(o.c.millisecond, 3);
        }
      }
      if (includeOffset) {
        if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
          c += "Z";
        } else if (o.o < 0) {
          c += "-";
          c += padStart(Math.trunc(-o.o / 60));
          c += ":";
          c += padStart(Math.trunc(-o.o % 60));
        } else {
          c += "+";
          c += padStart(Math.trunc(o.o / 60));
          c += ":";
          c += padStart(Math.trunc(o.o % 60));
        }
      }
      if (extendedZone) {
        c += "[" + o.zone.ianaName + "]";
      }
      return c;
    }
    var defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"];
    var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit(unit) {
      var normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    function quickDT(obj, opts) {
      var zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
      var ts, o;
      if (!isUndefined(obj.year)) {
        for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits), _step; !(_step = _iterator()).done; ) {
          var u = _step.value;
          if (isUndefined(obj[u])) {
            obj[u] = defaultUnitValues[u];
          }
        }
        var invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
        if (invalid) {
          return DateTime.invalid(invalid);
        }
        var offsetProvis = zone.offset(tsNow);
        var _objToTS = objToTS(obj, offsetProvis, zone);
        ts = _objToTS[0];
        o = _objToTS[1];
      } else {
        ts = tsNow;
      }
      return new DateTime({
        ts,
        zone,
        loc,
        o
      });
    }
    function diffRelative(start, end, opts) {
      var round = isUndefined(opts.round) ? true : opts.round, format = function format2(c, unit2) {
        c = roundTo(c, round || opts.calendary ? 0 : 2, true);
        var formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c, unit2);
      }, differ = function differ2(unit2) {
        if (opts.calendary) {
          if (!end.hasSame(start, unit2)) {
            return end.startOf(unit2).diff(start.startOf(unit2), unit2).get(unit2);
          } else
            return 0;
        } else {
          return end.diff(start, unit2).get(unit2);
        }
      };
      if (opts.unit) {
        return format(differ(opts.unit), opts.unit);
      }
      for (var _iterator2 = _createForOfIteratorHelperLoose(opts.units), _step2; !(_step2 = _iterator2()).done; ) {
        var unit = _step2.value;
        var count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format(count, unit);
        }
      }
      return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts(argList) {
      var opts = {}, args;
      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }
      return [opts, args];
    }
    var DateTime = /* @__PURE__ */ function() {
      function DateTime2(config) {
        var zone = config.zone || Settings.defaultZone;
        var invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
        this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
        var c = null, o = null;
        if (!invalid) {
          var unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
          if (unchanged) {
            var _ref = [config.old.c, config.old.o];
            c = _ref[0];
            o = _ref[1];
          } else {
            var ot = zone.offset(this.ts);
            c = tsToObj(this.ts, ot);
            invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
            c = invalid ? null : c;
            o = invalid ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config.loc || Locale.create();
        this.invalid = invalid;
        this.weekData = null;
        this.c = c;
        this.o = o;
        this.isLuxonDateTime = true;
      }
      DateTime2.now = function now2() {
        return new DateTime2({});
      };
      DateTime2.local = function local() {
        var _lastOpts = lastOpts(arguments), opts = _lastOpts[0], args = _lastOpts[1], year = args[0], month = args[1], day = args[2], hour = args[3], minute = args[4], second = args[5], millisecond = args[6];
        return quickDT({
          year,
          month,
          day,
          hour,
          minute,
          second,
          millisecond
        }, opts);
      };
      DateTime2.utc = function utc() {
        var _lastOpts2 = lastOpts(arguments), opts = _lastOpts2[0], args = _lastOpts2[1], year = args[0], month = args[1], day = args[2], hour = args[3], minute = args[4], second = args[5], millisecond = args[6];
        opts.zone = FixedOffsetZone.utcInstance;
        return quickDT({
          year,
          month,
          day,
          hour,
          minute,
          second,
          millisecond
        }, opts);
      };
      DateTime2.fromJSDate = function fromJSDate(date, options) {
        if (options === void 0) {
          options = {};
        }
        var ts = isDate(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return DateTime2.invalid("invalid input");
        }
        var zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime2.invalid(unsupportedZone(zoneToUse));
        }
        return new DateTime2({
          ts,
          zone: zoneToUse,
          loc: Locale.fromObject(options)
        });
      };
      DateTime2.fromMillis = function fromMillis(milliseconds, options) {
        if (options === void 0) {
          options = {};
        }
        if (!isNumber(milliseconds)) {
          throw new InvalidArgumentError("fromMillis requires a numerical input, but received a " + typeof milliseconds + " with value " + milliseconds);
        } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
          return DateTime2.invalid("Timestamp out of range");
        } else {
          return new DateTime2({
            ts: milliseconds,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      };
      DateTime2.fromSeconds = function fromSeconds(seconds, options) {
        if (options === void 0) {
          options = {};
        }
        if (!isNumber(seconds)) {
          throw new InvalidArgumentError("fromSeconds requires a numerical input");
        } else {
          return new DateTime2({
            ts: seconds * 1e3,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      };
      DateTime2.fromObject = function fromObject(obj, opts) {
        if (opts === void 0) {
          opts = {};
        }
        obj = obj || {};
        var zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime2.invalid(unsupportedZone(zoneToUse));
        }
        var tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        var useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        var units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits;
          defaultValues = defaultWeekUnitValues;
          objNow = gregorianToWeek(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits;
          defaultValues = defaultOrdinalUnitValues;
          objNow = gregorianToOrdinal(objNow);
        } else {
          units = orderedUnits;
          defaultValues = defaultUnitValues;
        }
        var foundFirst = false;
        for (var _iterator3 = _createForOfIteratorHelperLoose(units), _step3; !(_step3 = _iterator3()).done; ) {
          var u = _step3.value;
          var v = normalized[u];
          if (!isUndefined(v)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u] = defaultValues[u];
          } else {
            normalized[u] = objNow[u];
          }
        }
        var higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        var gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, _objToTS2 = objToTS(gregorian, offsetProvis, zoneToUse), tsFinal = _objToTS2[0], offsetFinal = _objToTS2[1], inst = new DateTime2({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return DateTime2.invalid("mismatched weekday", "you can't specify both a weekday of " + normalized.weekday + " and a date of " + inst.toISO());
        }
        return inst;
      };
      DateTime2.fromISO = function fromISO(text, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseISODate = parseISODate(text), vals = _parseISODate[0], parsedZone = _parseISODate[1];
        return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
      };
      DateTime2.fromRFC2822 = function fromRFC2822(text, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseRFC2822Date = parseRFC2822Date(text), vals = _parseRFC2822Date[0], parsedZone = _parseRFC2822Date[1];
        return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
      };
      DateTime2.fromHTTP = function fromHTTP(text, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseHTTPDate = parseHTTPDate(text), vals = _parseHTTPDate[0], parsedZone = _parseHTTPDate[1];
        return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
      };
      DateTime2.fromFormat = function fromFormat(text, fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (isUndefined(text) || isUndefined(fmt)) {
          throw new InvalidArgumentError("fromFormat requires an input string and a format");
        }
        var _opts = opts, _opts$locale = _opts.locale, locale = _opts$locale === void 0 ? null : _opts$locale, _opts$numberingSystem = _opts.numberingSystem, numberingSystem = _opts$numberingSystem === void 0 ? null : _opts$numberingSystem, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), _parseFromTokens = parseFromTokens(localeToUse, text, fmt), vals = _parseFromTokens[0], parsedZone = _parseFromTokens[1], specificOffset = _parseFromTokens[2], invalid = _parseFromTokens[3];
        if (invalid) {
          return DateTime2.invalid(invalid);
        } else {
          return parseDataToDateTime(vals, parsedZone, opts, "format " + fmt, text, specificOffset);
        }
      };
      DateTime2.fromString = function fromString(text, fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return DateTime2.fromFormat(text, fmt, opts);
      };
      DateTime2.fromSQL = function fromSQL(text, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseSQL = parseSQL(text), vals = _parseSQL[0], parsedZone = _parseSQL[1];
        return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
      };
      DateTime2.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
        }
        var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDateTimeError(invalid2);
        } else {
          return new DateTime2({
            invalid: invalid2
          });
        }
      };
      DateTime2.isDateTime = function isDateTime(o) {
        return o && o.isLuxonDateTime || false;
      };
      var _proto = DateTime2.prototype;
      _proto.get = function get(unit) {
        return this[unit];
      };
      _proto.resolvedLocaleOptions = function resolvedLocaleOptions(opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _Formatter$create$res = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this), locale = _Formatter$create$res.locale, numberingSystem = _Formatter$create$res.numberingSystem, calendar = _Formatter$create$res.calendar;
        return {
          locale,
          numberingSystem,
          outputCalendar: calendar
        };
      };
      _proto.toUTC = function toUTC(offset2, opts) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        if (opts === void 0) {
          opts = {};
        }
        return this.setZone(FixedOffsetZone.instance(offset2), opts);
      };
      _proto.toLocal = function toLocal() {
        return this.setZone(Settings.defaultZone);
      };
      _proto.setZone = function setZone(zone, _temp) {
        var _ref2 = _temp === void 0 ? {} : _temp, _ref2$keepLocalTime = _ref2.keepLocalTime, keepLocalTime = _ref2$keepLocalTime === void 0 ? false : _ref2$keepLocalTime, _ref2$keepCalendarTim = _ref2.keepCalendarTime, keepCalendarTime = _ref2$keepCalendarTim === void 0 ? false : _ref2$keepCalendarTim;
        zone = normalizeZone(zone, Settings.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return DateTime2.invalid(unsupportedZone(zone));
        } else {
          var newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            var offsetGuess = zone.offset(this.ts);
            var asObj = this.toObject();
            var _objToTS3 = objToTS(asObj, offsetGuess, zone);
            newTS = _objToTS3[0];
          }
          return clone(this, {
            ts: newTS,
            zone
          });
        }
      };
      _proto.reconfigure = function reconfigure(_temp2) {
        var _ref3 = _temp2 === void 0 ? {} : _temp2, locale = _ref3.locale, numberingSystem = _ref3.numberingSystem, outputCalendar = _ref3.outputCalendar;
        var loc = this.loc.clone({
          locale,
          numberingSystem,
          outputCalendar
        });
        return clone(this, {
          loc
        });
      };
      _proto.setLocale = function setLocale(locale) {
        return this.reconfigure({
          locale
        });
      };
      _proto.set = function set(values) {
        if (!this.isValid)
          return this;
        var normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        var mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian(_extends({}, gregorianToWeek(this.c), normalized));
        } else if (!isUndefined(normalized.ordinal)) {
          mixed = ordinalToGregorian(_extends({}, gregorianToOrdinal(this.c), normalized));
        } else {
          mixed = _extends({}, this.toObject(), normalized);
          if (isUndefined(normalized.day)) {
            mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
          }
        }
        var _objToTS4 = objToTS(mixed, this.o, this.zone), ts = _objToTS4[0], o = _objToTS4[1];
        return clone(this, {
          ts,
          o
        });
      };
      _proto.plus = function plus(duration) {
        if (!this.isValid)
          return this;
        var dur = Duration.fromDurationLike(duration);
        return clone(this, adjustTime(this, dur));
      };
      _proto.minus = function minus(duration) {
        if (!this.isValid)
          return this;
        var dur = Duration.fromDurationLike(duration).negate();
        return clone(this, adjustTime(this, dur));
      };
      _proto.startOf = function startOf(unit) {
        if (!this.isValid)
          return this;
        var o = {}, normalizedUnit = Duration.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o.month = 1;
          case "quarters":
          case "months":
            o.day = 1;
          case "weeks":
          case "days":
            o.hour = 0;
          case "hours":
            o.minute = 0;
          case "minutes":
            o.second = 0;
          case "seconds":
            o.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          o.weekday = 1;
        }
        if (normalizedUnit === "quarters") {
          var q = Math.ceil(this.month / 3);
          o.month = (q - 1) * 3 + 1;
        }
        return this.set(o);
      };
      _proto.endOf = function endOf(unit) {
        var _this$plus;
        return this.isValid ? this.plus((_this$plus = {}, _this$plus[unit] = 1, _this$plus)).startOf(unit).minus(1) : this;
      };
      _proto.toFormat = function toFormat(fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
      };
      _proto.toLocaleString = function toLocaleString(formatOpts, opts) {
        if (formatOpts === void 0) {
          formatOpts = DATE_SHORT;
        }
        if (opts === void 0) {
          opts = {};
        }
        return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
      };
      _proto.toLocaleParts = function toLocaleParts(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      };
      _proto.toISO = function toISO(_temp3) {
        var _ref4 = _temp3 === void 0 ? {} : _temp3, _ref4$format = _ref4.format, format = _ref4$format === void 0 ? "extended" : _ref4$format, _ref4$suppressSeconds = _ref4.suppressSeconds, suppressSeconds = _ref4$suppressSeconds === void 0 ? false : _ref4$suppressSeconds, _ref4$suppressMillise = _ref4.suppressMilliseconds, suppressMilliseconds = _ref4$suppressMillise === void 0 ? false : _ref4$suppressMillise, _ref4$includeOffset = _ref4.includeOffset, includeOffset = _ref4$includeOffset === void 0 ? true : _ref4$includeOffset, _ref4$extendedZone = _ref4.extendedZone, extendedZone = _ref4$extendedZone === void 0 ? false : _ref4$extendedZone;
        if (!this.isValid) {
          return null;
        }
        var ext = format === "extended";
        var c = _toISODate(this, ext);
        c += "T";
        c += _toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
        return c;
      };
      _proto.toISODate = function toISODate(_temp4) {
        var _ref5 = _temp4 === void 0 ? {} : _temp4, _ref5$format = _ref5.format, format = _ref5$format === void 0 ? "extended" : _ref5$format;
        if (!this.isValid) {
          return null;
        }
        return _toISODate(this, format === "extended");
      };
      _proto.toISOWeekDate = function toISOWeekDate() {
        return toTechFormat(this, "kkkk-'W'WW-c");
      };
      _proto.toISOTime = function toISOTime(_temp5) {
        var _ref6 = _temp5 === void 0 ? {} : _temp5, _ref6$suppressMillise = _ref6.suppressMilliseconds, suppressMilliseconds = _ref6$suppressMillise === void 0 ? false : _ref6$suppressMillise, _ref6$suppressSeconds = _ref6.suppressSeconds, suppressSeconds = _ref6$suppressSeconds === void 0 ? false : _ref6$suppressSeconds, _ref6$includeOffset = _ref6.includeOffset, includeOffset = _ref6$includeOffset === void 0 ? true : _ref6$includeOffset, _ref6$includePrefix = _ref6.includePrefix, includePrefix = _ref6$includePrefix === void 0 ? false : _ref6$includePrefix, _ref6$extendedZone = _ref6.extendedZone, extendedZone = _ref6$extendedZone === void 0 ? false : _ref6$extendedZone, _ref6$format = _ref6.format, format = _ref6$format === void 0 ? "extended" : _ref6$format;
        if (!this.isValid) {
          return null;
        }
        var c = includePrefix ? "T" : "";
        return c + _toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
      };
      _proto.toRFC2822 = function toRFC2822() {
        return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      };
      _proto.toHTTP = function toHTTP() {
        return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      };
      _proto.toSQLDate = function toSQLDate() {
        if (!this.isValid) {
          return null;
        }
        return _toISODate(this, true);
      };
      _proto.toSQLTime = function toSQLTime(_temp6) {
        var _ref7 = _temp6 === void 0 ? {} : _temp6, _ref7$includeOffset = _ref7.includeOffset, includeOffset = _ref7$includeOffset === void 0 ? true : _ref7$includeOffset, _ref7$includeZone = _ref7.includeZone, includeZone = _ref7$includeZone === void 0 ? false : _ref7$includeZone, _ref7$includeOffsetSp = _ref7.includeOffsetSpace, includeOffsetSpace = _ref7$includeOffsetSp === void 0 ? true : _ref7$includeOffsetSp;
        var fmt = "HH:mm:ss.SSS";
        if (includeZone || includeOffset) {
          if (includeOffsetSpace) {
            fmt += " ";
          }
          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }
        return toTechFormat(this, fmt, true);
      };
      _proto.toSQL = function toSQL(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid) {
          return null;
        }
        return this.toSQLDate() + " " + this.toSQLTime(opts);
      };
      _proto.toString = function toString() {
        return this.isValid ? this.toISO() : INVALID;
      };
      _proto.valueOf = function valueOf() {
        return this.toMillis();
      };
      _proto.toMillis = function toMillis() {
        return this.isValid ? this.ts : NaN;
      };
      _proto.toSeconds = function toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      };
      _proto.toUnixInteger = function toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
      };
      _proto.toJSON = function toJSON() {
        return this.toISO();
      };
      _proto.toBSON = function toBSON() {
        return this.toJSDate();
      };
      _proto.toObject = function toObject(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid)
          return {};
        var base = _extends({}, this.c);
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      };
      _proto.toJSDate = function toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      };
      _proto.diff = function diff(otherDateTime, unit, opts) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration.invalid("created by diffing an invalid DateTime");
        }
        var durOpts = _extends({
          locale: this.locale,
          numberingSystem: this.numberingSystem
        }, opts);
        var units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = _diff(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      };
      _proto.diffNow = function diffNow(unit, opts) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        if (opts === void 0) {
          opts = {};
        }
        return this.diff(DateTime2.now(), unit, opts);
      };
      _proto.until = function until(otherDateTime) {
        return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
      };
      _proto.hasSame = function hasSame(otherDateTime, unit) {
        if (!this.isValid)
          return false;
        var inputMs = otherDateTime.valueOf();
        var adjustedToZone = this.setZone(otherDateTime.zone, {
          keepLocalTime: true
        });
        return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
      };
      _proto.equals = function equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      };
      _proto.toRelative = function toRelative(options) {
        if (options === void 0) {
          options = {};
        }
        if (!this.isValid)
          return null;
        var base = options.base || DateTime2.fromObject({}, {
          zone: this.zone
        }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        var units = ["years", "months", "days", "hours", "minutes", "seconds"];
        var unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative(base, this.plus(padding), _extends({}, options, {
          numeric: "always",
          units,
          unit
        }));
      };
      _proto.toRelativeCalendar = function toRelativeCalendar(options) {
        if (options === void 0) {
          options = {};
        }
        if (!this.isValid)
          return null;
        return diffRelative(options.base || DateTime2.fromObject({}, {
          zone: this.zone
        }), this, _extends({}, options, {
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        }));
      };
      DateTime2.min = function min() {
        for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
          dateTimes[_key] = arguments[_key];
        }
        if (!dateTimes.every(DateTime2.isDateTime)) {
          throw new InvalidArgumentError("min requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, function(i) {
          return i.valueOf();
        }, Math.min);
      };
      DateTime2.max = function max() {
        for (var _len2 = arguments.length, dateTimes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          dateTimes[_key2] = arguments[_key2];
        }
        if (!dateTimes.every(DateTime2.isDateTime)) {
          throw new InvalidArgumentError("max requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, function(i) {
          return i.valueOf();
        }, Math.max);
      };
      DateTime2.fromFormatExplain = function fromFormatExplain(text, fmt, options) {
        if (options === void 0) {
          options = {};
        }
        var _options = options, _options$locale = _options.locale, locale = _options$locale === void 0 ? null : _options$locale, _options$numberingSys = _options.numberingSystem, numberingSystem = _options$numberingSys === void 0 ? null : _options$numberingSys, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens(localeToUse, text, fmt);
      };
      DateTime2.fromStringExplain = function fromStringExplain(text, fmt, options) {
        if (options === void 0) {
          options = {};
        }
        return DateTime2.fromFormatExplain(text, fmt, options);
      };
      _createClass(DateTime2, [{
        key: "isValid",
        get: function get() {
          return this.invalid === null;
        }
      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
      }, {
        key: "locale",
        get: function get() {
          return this.isValid ? this.loc.locale : null;
        }
      }, {
        key: "numberingSystem",
        get: function get() {
          return this.isValid ? this.loc.numberingSystem : null;
        }
      }, {
        key: "outputCalendar",
        get: function get() {
          return this.isValid ? this.loc.outputCalendar : null;
        }
      }, {
        key: "zone",
        get: function get() {
          return this._zone;
        }
      }, {
        key: "zoneName",
        get: function get() {
          return this.isValid ? this.zone.name : null;
        }
      }, {
        key: "year",
        get: function get() {
          return this.isValid ? this.c.year : NaN;
        }
      }, {
        key: "quarter",
        get: function get() {
          return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
        }
      }, {
        key: "month",
        get: function get() {
          return this.isValid ? this.c.month : NaN;
        }
      }, {
        key: "day",
        get: function get() {
          return this.isValid ? this.c.day : NaN;
        }
      }, {
        key: "hour",
        get: function get() {
          return this.isValid ? this.c.hour : NaN;
        }
      }, {
        key: "minute",
        get: function get() {
          return this.isValid ? this.c.minute : NaN;
        }
      }, {
        key: "second",
        get: function get() {
          return this.isValid ? this.c.second : NaN;
        }
      }, {
        key: "millisecond",
        get: function get() {
          return this.isValid ? this.c.millisecond : NaN;
        }
      }, {
        key: "weekYear",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
        }
      }, {
        key: "weekNumber",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
        }
      }, {
        key: "weekday",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
        }
      }, {
        key: "ordinal",
        get: function get() {
          return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
        }
      }, {
        key: "monthShort",
        get: function get() {
          return this.isValid ? Info.months("short", {
            locObj: this.loc
          })[this.month - 1] : null;
        }
      }, {
        key: "monthLong",
        get: function get() {
          return this.isValid ? Info.months("long", {
            locObj: this.loc
          })[this.month - 1] : null;
        }
      }, {
        key: "weekdayShort",
        get: function get() {
          return this.isValid ? Info.weekdays("short", {
            locObj: this.loc
          })[this.weekday - 1] : null;
        }
      }, {
        key: "weekdayLong",
        get: function get() {
          return this.isValid ? Info.weekdays("long", {
            locObj: this.loc
          })[this.weekday - 1] : null;
        }
      }, {
        key: "offset",
        get: function get() {
          return this.isValid ? +this.o : NaN;
        }
      }, {
        key: "offsetNameShort",
        get: function get() {
          if (this.isValid) {
            return this.zone.offsetName(this.ts, {
              format: "short",
              locale: this.locale
            });
          } else {
            return null;
          }
        }
      }, {
        key: "offsetNameLong",
        get: function get() {
          if (this.isValid) {
            return this.zone.offsetName(this.ts, {
              format: "long",
              locale: this.locale
            });
          } else {
            return null;
          }
        }
      }, {
        key: "isOffsetFixed",
        get: function get() {
          return this.isValid ? this.zone.isUniversal : null;
        }
      }, {
        key: "isInDST",
        get: function get() {
          if (this.isOffsetFixed) {
            return false;
          } else {
            return this.offset > this.set({
              month: 1,
              day: 1
            }).offset || this.offset > this.set({
              month: 5
            }).offset;
          }
        }
      }, {
        key: "isInLeapYear",
        get: function get() {
          return isLeapYear(this.year);
        }
      }, {
        key: "daysInMonth",
        get: function get() {
          return daysInMonth(this.year, this.month);
        }
      }, {
        key: "daysInYear",
        get: function get() {
          return this.isValid ? daysInYear(this.year) : NaN;
        }
      }, {
        key: "weeksInWeekYear",
        get: function get() {
          return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
        }
      }], [{
        key: "DATE_SHORT",
        get: function get() {
          return DATE_SHORT;
        }
      }, {
        key: "DATE_MED",
        get: function get() {
          return DATE_MED;
        }
      }, {
        key: "DATE_MED_WITH_WEEKDAY",
        get: function get() {
          return DATE_MED_WITH_WEEKDAY;
        }
      }, {
        key: "DATE_FULL",
        get: function get() {
          return DATE_FULL;
        }
      }, {
        key: "DATE_HUGE",
        get: function get() {
          return DATE_HUGE;
        }
      }, {
        key: "TIME_SIMPLE",
        get: function get() {
          return TIME_SIMPLE;
        }
      }, {
        key: "TIME_WITH_SECONDS",
        get: function get() {
          return TIME_WITH_SECONDS;
        }
      }, {
        key: "TIME_WITH_SHORT_OFFSET",
        get: function get() {
          return TIME_WITH_SHORT_OFFSET;
        }
      }, {
        key: "TIME_WITH_LONG_OFFSET",
        get: function get() {
          return TIME_WITH_LONG_OFFSET;
        }
      }, {
        key: "TIME_24_SIMPLE",
        get: function get() {
          return TIME_24_SIMPLE;
        }
      }, {
        key: "TIME_24_WITH_SECONDS",
        get: function get() {
          return TIME_24_WITH_SECONDS;
        }
      }, {
        key: "TIME_24_WITH_SHORT_OFFSET",
        get: function get() {
          return TIME_24_WITH_SHORT_OFFSET;
        }
      }, {
        key: "TIME_24_WITH_LONG_OFFSET",
        get: function get() {
          return TIME_24_WITH_LONG_OFFSET;
        }
      }, {
        key: "DATETIME_SHORT",
        get: function get() {
          return DATETIME_SHORT;
        }
      }, {
        key: "DATETIME_SHORT_WITH_SECONDS",
        get: function get() {
          return DATETIME_SHORT_WITH_SECONDS;
        }
      }, {
        key: "DATETIME_MED",
        get: function get() {
          return DATETIME_MED;
        }
      }, {
        key: "DATETIME_MED_WITH_SECONDS",
        get: function get() {
          return DATETIME_MED_WITH_SECONDS;
        }
      }, {
        key: "DATETIME_MED_WITH_WEEKDAY",
        get: function get() {
          return DATETIME_MED_WITH_WEEKDAY;
        }
      }, {
        key: "DATETIME_FULL",
        get: function get() {
          return DATETIME_FULL;
        }
      }, {
        key: "DATETIME_FULL_WITH_SECONDS",
        get: function get() {
          return DATETIME_FULL_WITH_SECONDS;
        }
      }, {
        key: "DATETIME_HUGE",
        get: function get() {
          return DATETIME_HUGE;
        }
      }, {
        key: "DATETIME_HUGE_WITH_SECONDS",
        get: function get() {
          return DATETIME_HUGE_WITH_SECONDS;
        }
      }]);
      return DateTime2;
    }();
    function friendlyDateTime(dateTimeish) {
      if (DateTime.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
        return DateTime.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError("Unknown datetime argument: " + dateTimeish + ", of type " + typeof dateTimeish);
      }
    }
    var VERSION = "2.4.0";
    var DateTime_1 = luxon.DateTime = DateTime;
    var Duration_1 = luxon.Duration = Duration;
    luxon.FixedOffsetZone = FixedOffsetZone;
    luxon.IANAZone = IANAZone;
    luxon.Info = Info;
    luxon.Interval = Interval;
    luxon.InvalidZone = InvalidZone;
    luxon.Settings = Settings;
    luxon.SystemZone = SystemZone;
    luxon.VERSION = VERSION;
    luxon.Zone = Zone;
    var DEFAULT_QUERY_SETTINGS = {
      renderNullAs: "\\-",
      taskCompletionTracking: false,
      taskCompletionUseEmojiShorthand: false,
      taskCompletionText: "completion",
      taskCompletionDateFormat: "yyyy-MM-dd",
      recursiveSubTaskCompletion: false,
      warnOnEmptyResult: true,
      refreshEnabled: true,
      refreshInterval: 2500,
      defaultDateFormat: "MMMM dd, yyyy",
      defaultDateTimeFormat: "h:mm a - MMMM dd, yyyy",
      maxRecursiveRenderDepth: 4,
      tableIdColumnName: "File",
      tableGroupColumnName: "Group"
    };
    var DEFAULT_EXPORT_SETTINGS = {
      allowHtml: true
    };
    __spreadValues(__spreadValues(__spreadValues({}, DEFAULT_QUERY_SETTINGS), DEFAULT_EXPORT_SETTINGS), {
      inlineQueryPrefix: "=",
      inlineJsQueryPrefix: "$=",
      inlineQueriesInCodeblocks: true,
      enableInlineDataview: true,
      enableDataviewJs: false,
      enableInlineDataviewJs: false,
      prettyRenderInlineFields: true
    });
    var Success = class {
      constructor(value) {
        this.value = value;
        this.successful = true;
      }
      map(f) {
        return new Success(f(this.value));
      }
      flatMap(f) {
        return f(this.value);
      }
      mapErr(f) {
        return this;
      }
      bimap(succ, _fail) {
        return this.map(succ);
      }
      orElse(_value) {
        return this.value;
      }
      cast() {
        return this;
      }
      orElseThrow(_message) {
        return this.value;
      }
    };
    var Failure = class {
      constructor(error) {
        this.error = error;
        this.successful = false;
      }
      map(_f) {
        return this;
      }
      flatMap(_f) {
        return this;
      }
      mapErr(f) {
        return new Failure(f(this.error));
      }
      bimap(_succ, fail) {
        return this.mapErr(fail);
      }
      orElse(value) {
        return value;
      }
      cast() {
        return this;
      }
      orElseThrow(message) {
        if (message)
          throw new Error(message(this.error));
        else
          throw new Error("" + this.error);
      }
    };
    var Result;
    (function(Result2) {
      function success(value) {
        return new Success(value);
      }
      Result2.success = success;
      function failure(error) {
        return new Failure(error);
      }
      Result2.failure = failure;
      function flatMap2(first, second, f) {
        if (first.successful) {
          if (second.successful)
            return f(first.value, second.value);
          else
            return failure(second.error);
        } else {
          return failure(first.error);
        }
      }
      Result2.flatMap2 = flatMap2;
      function map2(first, second, f) {
        return flatMap2(first, second, (a, b) => success(f(a, b)));
      }
      Result2.map2 = map2;
    })(Result || (Result = {}));
    var parsimmon_umd_min = { exports: {} };
    (function(module3, exports2) {
      !function(n2, t) {
        module3.exports = t();
      }(typeof self != "undefined" ? self : commonjsGlobal, function() {
        return function(n2) {
          var t = {};
          function r(e) {
            if (t[e])
              return t[e].exports;
            var u = t[e] = { i: e, l: false, exports: {} };
            return n2[e].call(u.exports, u, u.exports, r), u.l = true, u.exports;
          }
          return r.m = n2, r.c = t, r.d = function(n3, t2, e) {
            r.o(n3, t2) || Object.defineProperty(n3, t2, { configurable: false, enumerable: true, get: e });
          }, r.r = function(n3) {
            Object.defineProperty(n3, "__esModule", { value: true });
          }, r.n = function(n3) {
            var t2 = n3 && n3.__esModule ? function() {
              return n3.default;
            } : function() {
              return n3;
            };
            return r.d(t2, "a", t2), t2;
          }, r.o = function(n3, t2) {
            return Object.prototype.hasOwnProperty.call(n3, t2);
          }, r.p = "", r(r.s = 0);
        }([function(n2, t, r) {
          function e(n3) {
            if (!(this instanceof e))
              return new e(n3);
            this._ = n3;
          }
          var u = e.prototype;
          function o(n3, t2) {
            for (var r2 = 0; r2 < n3; r2++)
              t2(r2);
          }
          function i(n3, t2, r2) {
            return function(n4, t3) {
              o(t3.length, function(r3) {
                n4(t3[r3], r3, t3);
              });
            }(function(r3, e2, u2) {
              t2 = n3(t2, r3, e2, u2);
            }, r2), t2;
          }
          function a(n3, t2) {
            return i(function(t3, r2, e2, u2) {
              return t3.concat([n3(r2, e2, u2)]);
            }, [], t2);
          }
          function f(n3, t2) {
            var r2 = { v: 0, buf: t2 };
            return o(n3, function() {
              var n4;
              r2 = { v: r2.v << 1 | (n4 = r2.buf, n4[0] >> 7), buf: function(n5) {
                var t3 = i(function(n6, t4, r3, e2) {
                  return n6.concat(r3 === e2.length - 1 ? Buffer.from([t4, 0]).readUInt16BE(0) : e2.readUInt16BE(r3));
                }, [], n5);
                return Buffer.from(a(function(n6) {
                  return (n6 << 1 & 65535) >> 8;
                }, t3));
              }(r2.buf) };
            }), r2;
          }
          function c() {
            return typeof Buffer != "undefined";
          }
          function s2() {
            if (!c())
              throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
          }
          function l2(n3) {
            s2();
            var t2 = i(function(n4, t3) {
              return n4 + t3;
            }, 0, n3);
            if (t2 % 8 != 0)
              throw new Error("The bits [" + n3.join(", ") + "] add up to " + t2 + " which is not an even number of bytes; the total should be divisible by 8");
            var r2, u2 = t2 / 8, o2 = (r2 = function(n4) {
              return n4 > 48;
            }, i(function(n4, t3) {
              return n4 || (r2(t3) ? t3 : n4);
            }, null, n3));
            if (o2)
              throw new Error(o2 + " bit range requested exceeds 48 bit (6 byte) Number max.");
            return new e(function(t3, r3) {
              var e2 = u2 + r3;
              return e2 > t3.length ? x(r3, u2.toString() + " bytes") : b(e2, i(function(n4, t4) {
                var r4 = f(t4, n4.buf);
                return { coll: n4.coll.concat(r4.v), buf: r4.buf };
              }, { coll: [], buf: t3.slice(r3, e2) }, n3).coll);
            });
          }
          function h(n3, t2) {
            return new e(function(r2, e2) {
              return s2(), e2 + t2 > r2.length ? x(e2, t2 + " bytes for " + n3) : b(e2 + t2, r2.slice(e2, e2 + t2));
            });
          }
          function p(n3, t2) {
            if (typeof (r2 = t2) != "number" || Math.floor(r2) !== r2 || t2 < 0 || t2 > 6)
              throw new Error(n3 + " requires integer length in range [0, 6].");
            var r2;
          }
          function d(n3) {
            return p("uintBE", n3), h("uintBE(" + n3 + ")", n3).map(function(t2) {
              return t2.readUIntBE(0, n3);
            });
          }
          function v(n3) {
            return p("uintLE", n3), h("uintLE(" + n3 + ")", n3).map(function(t2) {
              return t2.readUIntLE(0, n3);
            });
          }
          function g(n3) {
            return p("intBE", n3), h("intBE(" + n3 + ")", n3).map(function(t2) {
              return t2.readIntBE(0, n3);
            });
          }
          function m(n3) {
            return p("intLE", n3), h("intLE(" + n3 + ")", n3).map(function(t2) {
              return t2.readIntLE(0, n3);
            });
          }
          function y(n3) {
            return n3 instanceof e;
          }
          function E(n3) {
            return {}.toString.call(n3) === "[object Array]";
          }
          function w(n3) {
            return c() && Buffer.isBuffer(n3);
          }
          function b(n3, t2) {
            return { status: true, index: n3, value: t2, furthest: -1, expected: [] };
          }
          function x(n3, t2) {
            return E(t2) || (t2 = [t2]), { status: false, index: -1, value: null, furthest: n3, expected: t2 };
          }
          function B(n3, t2) {
            if (!t2)
              return n3;
            if (n3.furthest > t2.furthest)
              return n3;
            var r2 = n3.furthest === t2.furthest ? function(n4, t3) {
              if (function() {
                if (e._supportsSet !== void 0)
                  return e._supportsSet;
                var n5 = typeof Set != "undefined";
                return e._supportsSet = n5, n5;
              }() && Array.from) {
                for (var r3 = new Set(n4), u2 = 0; u2 < t3.length; u2++)
                  r3.add(t3[u2]);
                var o2 = Array.from(r3);
                return o2.sort(), o2;
              }
              for (var i2 = {}, a2 = 0; a2 < n4.length; a2++)
                i2[n4[a2]] = true;
              for (var f2 = 0; f2 < t3.length; f2++)
                i2[t3[f2]] = true;
              var c2 = [];
              for (var s3 in i2)
                ({}).hasOwnProperty.call(i2, s3) && c2.push(s3);
              return c2.sort(), c2;
            }(n3.expected, t2.expected) : t2.expected;
            return { status: n3.status, index: n3.index, value: n3.value, furthest: t2.furthest, expected: r2 };
          }
          var j = {};
          function S(n3, t2) {
            if (w(n3))
              return { offset: t2, line: -1, column: -1 };
            n3 in j || (j[n3] = {});
            for (var r2 = j[n3], e2 = 0, u2 = 0, o2 = 0, i2 = t2; i2 >= 0; ) {
              if (i2 in r2) {
                e2 = r2[i2].line, o2 === 0 && (o2 = r2[i2].lineStart);
                break;
              }
              (n3.charAt(i2) === "\n" || n3.charAt(i2) === "\r" && n3.charAt(i2 + 1) !== "\n") && (u2++, o2 === 0 && (o2 = i2 + 1)), i2--;
            }
            var a2 = e2 + u2, f2 = t2 - o2;
            return r2[t2] = { line: a2, lineStart: o2 }, { offset: t2, line: a2 + 1, column: f2 + 1 };
          }
          function _(n3) {
            if (!y(n3))
              throw new Error("not a parser: " + n3);
          }
          function L(n3, t2) {
            return typeof n3 == "string" ? n3.charAt(t2) : n3[t2];
          }
          function O(n3) {
            if (typeof n3 != "number")
              throw new Error("not a number: " + n3);
          }
          function k(n3) {
            if (typeof n3 != "function")
              throw new Error("not a function: " + n3);
          }
          function P(n3) {
            if (typeof n3 != "string")
              throw new Error("not a string: " + n3);
          }
          var q = 2, A = 3, I = 8, F = 5 * I, M = 4 * I, z = "  ";
          function R(n3, t2) {
            return new Array(t2 + 1).join(n3);
          }
          function U(n3, t2, r2) {
            var e2 = t2 - n3.length;
            return e2 <= 0 ? n3 : R(r2, e2) + n3;
          }
          function W(n3, t2, r2, e2) {
            return { from: n3 - t2 > 0 ? n3 - t2 : 0, to: n3 + r2 > e2 ? e2 : n3 + r2 };
          }
          function D(n3, t2) {
            var r2, e2, u2, o2, f2, c2 = t2.index, s3 = c2.offset, l3 = 1;
            if (s3 === n3.length)
              return "Got the end of the input";
            if (w(n3)) {
              var h2 = s3 - s3 % I, p2 = s3 - h2, d2 = W(h2, F, M + I, n3.length), v2 = a(function(n4) {
                return a(function(n5) {
                  return U(n5.toString(16), 2, "0");
                }, n4);
              }, function(n4, t3) {
                var r3 = n4.length, e3 = [], u3 = 0;
                if (r3 <= t3)
                  return [n4.slice()];
                for (var o3 = 0; o3 < r3; o3++)
                  e3[u3] || e3.push([]), e3[u3].push(n4[o3]), (o3 + 1) % t3 == 0 && u3++;
                return e3;
              }(n3.slice(d2.from, d2.to).toJSON().data, I));
              o2 = function(n4) {
                return n4.from === 0 && n4.to === 1 ? { from: n4.from, to: n4.to } : { from: n4.from / I, to: Math.floor(n4.to / I) };
              }(d2), e2 = h2 / I, r2 = 3 * p2, p2 >= 4 && (r2 += 1), l3 = 2, u2 = a(function(n4) {
                return n4.length <= 4 ? n4.join(" ") : n4.slice(0, 4).join(" ") + "  " + n4.slice(4).join(" ");
              }, v2), (f2 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f2 = 2);
            } else {
              var g2 = n3.split(/\r\n|[\n\r\u2028\u2029]/);
              r2 = c2.column - 1, e2 = c2.line - 1, o2 = W(e2, q, A, g2.length), u2 = g2.slice(o2.from, o2.to), f2 = o2.to.toString().length;
            }
            var m2 = e2 - o2.from;
            return w(n3) && (f2 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f2 = 2), i(function(t3, e3, u3) {
              var i2, a2 = u3 === m2, c3 = a2 ? "> " : z;
              return i2 = w(n3) ? U((8 * (o2.from + u3)).toString(16), f2, "0") : U((o2.from + u3 + 1).toString(), f2, " "), [].concat(t3, [c3 + i2 + " | " + e3], a2 ? [z + R(" ", f2) + " | " + U("", r2, " ") + R("^", l3)] : []);
            }, [], u2).join("\n");
          }
          function N(n3, t2) {
            return ["\n", "-- PARSING FAILED " + R("-", 50), "\n\n", D(n3, t2), "\n\n", (r2 = t2.expected, r2.length === 1 ? "Expected:\n\n" + r2[0] : "Expected one of the following: \n\n" + r2.join(", ")), "\n"].join("");
            var r2;
          }
          function G(n3) {
            return n3.flags !== void 0 ? n3.flags : [n3.global ? "g" : "", n3.ignoreCase ? "i" : "", n3.multiline ? "m" : "", n3.unicode ? "u" : "", n3.sticky ? "y" : ""].join("");
          }
          function C() {
            for (var n3 = [].slice.call(arguments), t2 = n3.length, r2 = 0; r2 < t2; r2 += 1)
              _(n3[r2]);
            return e(function(r3, e2) {
              for (var u2, o2 = new Array(t2), i2 = 0; i2 < t2; i2 += 1) {
                if (!(u2 = B(n3[i2]._(r3, e2), u2)).status)
                  return u2;
                o2[i2] = u2.value, e2 = u2.index;
              }
              return B(b(e2, o2), u2);
            });
          }
          function J() {
            var n3 = [].slice.call(arguments);
            if (n3.length === 0)
              throw new Error("seqMap needs at least one argument");
            var t2 = n3.pop();
            return k(t2), C.apply(null, n3).map(function(n4) {
              return t2.apply(null, n4);
            });
          }
          function T() {
            var n3 = [].slice.call(arguments), t2 = n3.length;
            if (t2 === 0)
              return Y("zero alternates");
            for (var r2 = 0; r2 < t2; r2 += 1)
              _(n3[r2]);
            return e(function(t3, r3) {
              for (var e2, u2 = 0; u2 < n3.length; u2 += 1)
                if ((e2 = B(n3[u2]._(t3, r3), e2)).status)
                  return e2;
              return e2;
            });
          }
          function V(n3, t2) {
            return H(n3, t2).or(X([]));
          }
          function H(n3, t2) {
            return _(n3), _(t2), J(n3, t2.then(n3).many(), function(n4, t3) {
              return [n4].concat(t3);
            });
          }
          function K(n3) {
            P(n3);
            var t2 = "'" + n3 + "'";
            return e(function(r2, e2) {
              var u2 = e2 + n3.length, o2 = r2.slice(e2, u2);
              return o2 === n3 ? b(u2, o2) : x(e2, t2);
            });
          }
          function Q(n3, t2) {
            !function(n4) {
              if (!(n4 instanceof RegExp))
                throw new Error("not a regexp: " + n4);
              for (var t3 = G(n4), r3 = 0; r3 < t3.length; r3++) {
                var e2 = t3.charAt(r3);
                if (e2 !== "i" && e2 !== "m" && e2 !== "u" && e2 !== "s")
                  throw new Error('unsupported regexp flag "' + e2 + '": ' + n4);
              }
            }(n3), arguments.length >= 2 ? O(t2) : t2 = 0;
            var r2 = function(n4) {
              return RegExp("^(?:" + n4.source + ")", G(n4));
            }(n3), u2 = "" + n3;
            return e(function(n4, e2) {
              var o2 = r2.exec(n4.slice(e2));
              if (o2) {
                if (0 <= t2 && t2 <= o2.length) {
                  var i2 = o2[0], a2 = o2[t2];
                  return b(e2 + i2.length, a2);
                }
                return x(e2, "valid match group (0 to " + o2.length + ") in " + u2);
              }
              return x(e2, u2);
            });
          }
          function X(n3) {
            return e(function(t2, r2) {
              return b(r2, n3);
            });
          }
          function Y(n3) {
            return e(function(t2, r2) {
              return x(r2, n3);
            });
          }
          function Z(n3) {
            if (y(n3))
              return e(function(t2, r2) {
                var e2 = n3._(t2, r2);
                return e2.index = r2, e2.value = "", e2;
              });
            if (typeof n3 == "string")
              return Z(K(n3));
            if (n3 instanceof RegExp)
              return Z(Q(n3));
            throw new Error("not a string, regexp, or parser: " + n3);
          }
          function $(n3) {
            return _(n3), e(function(t2, r2) {
              var e2 = n3._(t2, r2), u2 = t2.slice(r2, e2.index);
              return e2.status ? x(r2, 'not "' + u2 + '"') : b(r2, null);
            });
          }
          function nn(n3) {
            return k(n3), e(function(t2, r2) {
              var e2 = L(t2, r2);
              return r2 < t2.length && n3(e2) ? b(r2 + 1, e2) : x(r2, "a character/byte matching " + n3);
            });
          }
          function tn(n3, t2) {
            arguments.length < 2 && (t2 = n3, n3 = void 0);
            var r2 = e(function(n4, e2) {
              return r2._ = t2()._, r2._(n4, e2);
            });
            return n3 ? r2.desc(n3) : r2;
          }
          function rn() {
            return Y("fantasy-land/empty");
          }
          u.parse = function(n3) {
            if (typeof n3 != "string" && !w(n3))
              throw new Error(".parse must be called with a string or Buffer as its argument");
            var t2, r2 = this.skip(an)._(n3, 0);
            return t2 = r2.status ? { status: true, value: r2.value } : { status: false, index: S(n3, r2.furthest), expected: r2.expected }, delete j[n3], t2;
          }, u.tryParse = function(n3) {
            var t2 = this.parse(n3);
            if (t2.status)
              return t2.value;
            var r2 = N(n3, t2), e2 = new Error(r2);
            throw e2.type = "ParsimmonError", e2.result = t2, e2;
          }, u.assert = function(n3, t2) {
            return this.chain(function(r2) {
              return n3(r2) ? X(r2) : Y(t2);
            });
          }, u.or = function(n3) {
            return T(this, n3);
          }, u.trim = function(n3) {
            return this.wrap(n3, n3);
          }, u.wrap = function(n3, t2) {
            return J(n3, this, t2, function(n4, t3) {
              return t3;
            });
          }, u.thru = function(n3) {
            return n3(this);
          }, u.then = function(n3) {
            return _(n3), C(this, n3).map(function(n4) {
              return n4[1];
            });
          }, u.many = function() {
            var n3 = this;
            return e(function(t2, r2) {
              for (var e2 = [], u2 = void 0; ; ) {
                if (!(u2 = B(n3._(t2, r2), u2)).status)
                  return B(b(r2, e2), u2);
                if (r2 === u2.index)
                  throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
                r2 = u2.index, e2.push(u2.value);
              }
            });
          }, u.tieWith = function(n3) {
            return P(n3), this.map(function(t2) {
              if (function(n4) {
                if (!E(n4))
                  throw new Error("not an array: " + n4);
              }(t2), t2.length) {
                P(t2[0]);
                for (var r2 = t2[0], e2 = 1; e2 < t2.length; e2++)
                  P(t2[e2]), r2 += n3 + t2[e2];
                return r2;
              }
              return "";
            });
          }, u.tie = function() {
            return this.tieWith("");
          }, u.times = function(n3, t2) {
            var r2 = this;
            return arguments.length < 2 && (t2 = n3), O(n3), O(t2), e(function(e2, u2) {
              for (var o2 = [], i2 = void 0, a2 = void 0, f2 = 0; f2 < n3; f2 += 1) {
                if (a2 = B(i2 = r2._(e2, u2), a2), !i2.status)
                  return a2;
                u2 = i2.index, o2.push(i2.value);
              }
              for (; f2 < t2 && (a2 = B(i2 = r2._(e2, u2), a2), i2.status); f2 += 1)
                u2 = i2.index, o2.push(i2.value);
              return B(b(u2, o2), a2);
            });
          }, u.result = function(n3) {
            return this.map(function() {
              return n3;
            });
          }, u.atMost = function(n3) {
            return this.times(0, n3);
          }, u.atLeast = function(n3) {
            return J(this.times(n3), this.many(), function(n4, t2) {
              return n4.concat(t2);
            });
          }, u.map = function(n3) {
            k(n3);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status ? B(b(u2.index, n3(u2.value)), u2) : u2;
            });
          }, u.contramap = function(n3) {
            k(n3);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2.parse(n3(r2.slice(e2)));
              return u2.status ? b(e2 + r2.length, u2.value) : u2;
            });
          }, u.promap = function(n3, t2) {
            return k(n3), k(t2), this.contramap(n3).map(t2);
          }, u.skip = function(n3) {
            return C(this, n3).map(function(n4) {
              return n4[0];
            });
          }, u.mark = function() {
            return J(en, this, en, function(n3, t2, r2) {
              return { start: n3, value: t2, end: r2 };
            });
          }, u.node = function(n3) {
            return J(en, this, en, function(t2, r2, e2) {
              return { name: n3, value: r2, start: t2, end: e2 };
            });
          }, u.sepBy = function(n3) {
            return V(this, n3);
          }, u.sepBy1 = function(n3) {
            return H(this, n3);
          }, u.lookahead = function(n3) {
            return this.skip(Z(n3));
          }, u.notFollowedBy = function(n3) {
            return this.skip($(n3));
          }, u.desc = function(n3) {
            E(n3) || (n3 = [n3]);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status || (u2.expected = n3), u2;
            });
          }, u.fallback = function(n3) {
            return this.or(X(n3));
          }, u.ap = function(n3) {
            return J(n3, this, function(n4, t2) {
              return n4(t2);
            });
          }, u.chain = function(n3) {
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status ? B(n3(u2.value)._(r2, u2.index), u2) : u2;
            });
          }, u.concat = u.or, u.empty = rn, u.of = X, u["fantasy-land/ap"] = u.ap, u["fantasy-land/chain"] = u.chain, u["fantasy-land/concat"] = u.concat, u["fantasy-land/empty"] = u.empty, u["fantasy-land/of"] = u.of, u["fantasy-land/map"] = u.map;
          var en = e(function(n3, t2) {
            return b(t2, S(n3, t2));
          }), un = e(function(n3, t2) {
            return t2 >= n3.length ? x(t2, "any character/byte") : b(t2 + 1, L(n3, t2));
          }), on = e(function(n3, t2) {
            return b(n3.length, n3.slice(t2));
          }), an = e(function(n3, t2) {
            return t2 < n3.length ? x(t2, "EOF") : b(t2, null);
          }), fn = Q(/[0-9]/).desc("a digit"), cn = Q(/[0-9]*/).desc("optional digits"), sn = Q(/[a-z]/i).desc("a letter"), ln = Q(/[a-z]*/i).desc("optional letters"), hn = Q(/\s*/).desc("optional whitespace"), pn = Q(/\s+/).desc("whitespace"), dn = K("\r"), vn = K("\n"), gn = K("\r\n"), mn = T(gn, vn, dn).desc("newline"), yn = T(mn, an);
          e.all = on, e.alt = T, e.any = un, e.cr = dn, e.createLanguage = function(n3) {
            var t2 = {};
            for (var r2 in n3)
              ({}).hasOwnProperty.call(n3, r2) && function(r3) {
                t2[r3] = tn(function() {
                  return n3[r3](t2);
                });
              }(r2);
            return t2;
          }, e.crlf = gn, e.custom = function(n3) {
            return e(n3(b, x));
          }, e.digit = fn, e.digits = cn, e.empty = rn, e.end = yn, e.eof = an, e.fail = Y, e.formatError = N, e.index = en, e.isParser = y, e.lazy = tn, e.letter = sn, e.letters = ln, e.lf = vn, e.lookahead = Z, e.makeFailure = x, e.makeSuccess = b, e.newline = mn, e.noneOf = function(n3) {
            return nn(function(t2) {
              return n3.indexOf(t2) < 0;
            }).desc("none of '" + n3 + "'");
          }, e.notFollowedBy = $, e.of = X, e.oneOf = function(n3) {
            for (var t2 = n3.split(""), r2 = 0; r2 < t2.length; r2++)
              t2[r2] = "'" + t2[r2] + "'";
            return nn(function(t3) {
              return n3.indexOf(t3) >= 0;
            }).desc(t2);
          }, e.optWhitespace = hn, e.Parser = e, e.range = function(n3, t2) {
            return nn(function(r2) {
              return n3 <= r2 && r2 <= t2;
            }).desc(n3 + "-" + t2);
          }, e.regex = Q, e.regexp = Q, e.sepBy = V, e.sepBy1 = H, e.seq = C, e.seqMap = J, e.seqObj = function() {
            for (var n3, t2 = {}, r2 = 0, u2 = (n3 = arguments, Array.prototype.slice.call(n3)), o2 = u2.length, i2 = 0; i2 < o2; i2 += 1) {
              var a2 = u2[i2];
              if (!y(a2)) {
                if (E(a2) && a2.length === 2 && typeof a2[0] == "string" && y(a2[1])) {
                  var f2 = a2[0];
                  if (Object.prototype.hasOwnProperty.call(t2, f2))
                    throw new Error("seqObj: duplicate key " + f2);
                  t2[f2] = true, r2++;
                  continue;
                }
                throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
              }
            }
            if (r2 === 0)
              throw new Error("seqObj expects at least one named parser, found zero");
            return e(function(n4, t3) {
              for (var r3, e2 = {}, i3 = 0; i3 < o2; i3 += 1) {
                var a3, f3;
                if (E(u2[i3]) ? (a3 = u2[i3][0], f3 = u2[i3][1]) : (a3 = null, f3 = u2[i3]), !(r3 = B(f3._(n4, t3), r3)).status)
                  return r3;
                a3 && (e2[a3] = r3.value), t3 = r3.index;
              }
              return B(b(t3, e2), r3);
            });
          }, e.string = K, e.succeed = X, e.takeWhile = function(n3) {
            return k(n3), e(function(t2, r2) {
              for (var e2 = r2; e2 < t2.length && n3(L(t2, e2)); )
                e2++;
              return b(e2, t2.slice(r2, e2));
            });
          }, e.test = nn, e.whitespace = pn, e["fantasy-land/empty"] = rn, e["fantasy-land/of"] = X, e.Binary = { bitSeq: l2, bitSeqObj: function(n3) {
            s2();
            var t2 = {}, r2 = 0, e2 = a(function(n4) {
              if (E(n4)) {
                var e3 = n4;
                if (e3.length !== 2)
                  throw new Error("[" + e3.join(", ") + "] should be length 2, got length " + e3.length);
                if (P(e3[0]), O(e3[1]), Object.prototype.hasOwnProperty.call(t2, e3[0]))
                  throw new Error("duplicate key in bitSeqObj: " + e3[0]);
                return t2[e3[0]] = true, r2++, e3;
              }
              return O(n4), [null, n4];
            }, n3);
            if (r2 < 1)
              throw new Error("bitSeqObj expects at least one named pair, got [" + n3.join(", ") + "]");
            var u2 = a(function(n4) {
              return n4[0];
            }, e2);
            return l2(a(function(n4) {
              return n4[1];
            }, e2)).map(function(n4) {
              return i(function(n5, t3) {
                return t3[0] !== null && (n5[t3[0]] = t3[1]), n5;
              }, {}, a(function(t3, r3) {
                return [t3, n4[r3]];
              }, u2));
            });
          }, byte: function(n3) {
            if (s2(), O(n3), n3 > 255)
              throw new Error("Value specified to byte constructor (" + n3 + "=0x" + n3.toString(16) + ") is larger in value than a single byte.");
            var t2 = (n3 > 15 ? "0x" : "0x0") + n3.toString(16);
            return e(function(r2, e2) {
              var u2 = L(r2, e2);
              return u2 === n3 ? b(e2 + 1, u2) : x(e2, t2);
            });
          }, buffer: function(n3) {
            return h("buffer", n3).map(function(n4) {
              return Buffer.from(n4);
            });
          }, encodedString: function(n3, t2) {
            return h("string", t2).map(function(t3) {
              return t3.toString(n3);
            });
          }, uintBE: d, uint8BE: d(1), uint16BE: d(2), uint32BE: d(4), uintLE: v, uint8LE: v(1), uint16LE: v(2), uint32LE: v(4), intBE: g, int8BE: g(1), int16BE: g(2), int32BE: g(4), intLE: m, int8LE: m(1), int16LE: m(2), int32LE: m(4), floatBE: h("floatBE", 4).map(function(n3) {
            return n3.readFloatBE(0);
          }), floatLE: h("floatLE", 4).map(function(n3) {
            return n3.readFloatLE(0);
          }), doubleBE: h("doubleBE", 8).map(function(n3) {
            return n3.readDoubleBE(0);
          }), doubleLE: h("doubleLE", 8).map(function(n3) {
            return n3.readDoubleLE(0);
          }) }, n2.exports = e;
        }]);
      });
    })(parsimmon_umd_min);
    var emojiRegex = () => {
      return /(?:[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDD-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF6](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC2\uDED0-\uDED9\uDEE0-\uDEE7]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?))/g;
    };
    function normalizeDuration(dur) {
      if (dur === void 0 || dur === null)
        return dur;
      return dur.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds").normalize();
    }
    function getFileTitle(path) {
      if (path.includes("/"))
        path = path.substring(path.lastIndexOf("/") + 1);
      if (path.endsWith(".md"))
        path = path.substring(0, path.length - 3);
      return path;
    }
    parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_min.exports.regex(/[0-9\p{Letter}_-]+/u).map((str) => str.toLocaleLowerCase()), parsimmon_umd_min.exports.whitespace.map((_) => "-"), parsimmon_umd_min.exports.any.map((_) => "")).many().map((result) => result.join(""));
    var HEADER_CANONICALIZER = parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_min.exports.regex(/[0-9\p{Letter}_-]+/u), parsimmon_umd_min.exports.whitespace.map((_) => " "), parsimmon_umd_min.exports.any.map((_) => " ")).many().map((result) => {
      return result.join("").split(/\s+/).join(" ").trim();
    });
    function normalizeHeaderForLink(header) {
      return HEADER_CANONICALIZER.tryParse(header);
    }
    function renderMinimalDuration(dur) {
      dur = normalizeDuration(dur);
      let result = "";
      if (dur.years)
        result += `${dur.years} years, `;
      if (dur.months)
        result += `${dur.months} months, `;
      if (dur.weeks)
        result += `${dur.weeks} weeks, `;
      if (dur.days)
        result += `${dur.days} days, `;
      if (dur.hours)
        result += `${dur.hours} hours, `;
      if (dur.minutes)
        result += `${dur.minutes} minutes, `;
      if (dur.seconds)
        result += `${Math.round(dur.seconds)} seconds, `;
      if (dur.milliseconds)
        result += `${Math.round(dur.milliseconds)} ms, `;
      if (result.endsWith(", "))
        result = result.substring(0, result.length - 2);
      return result;
    }
    var Values;
    (function(Values2) {
      function toString(field, setting = DEFAULT_QUERY_SETTINGS, recursive = false) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return setting.renderNullAs;
        switch (wrapped.type) {
          case "null":
            return setting.renderNullAs;
          case "string":
            return wrapped.value;
          case "number":
          case "boolean":
            return "" + wrapped.value;
          case "html":
            return wrapped.value.outerHTML;
          case "widget":
            return wrapped.value.markdown();
          case "link":
            return wrapped.value.markdown();
          case "function":
            return "<function>";
          case "array":
            let result = "";
            if (recursive)
              result += "[";
            result += wrapped.value.map((f) => toString(f, setting, true)).join(", ");
            if (recursive)
              result += "]";
            return result;
          case "object":
            return "{ " + Object.entries(wrapped.value).map((e) => e[0] + ": " + toString(e[1], setting, true)).join(", ") + " }";
          case "date":
            if (wrapped.value.second == 0 && wrapped.value.hour == 0 && wrapped.value.minute == 0) {
              return wrapped.value.toFormat(setting.defaultDateFormat);
            }
            return wrapped.value.toFormat(setting.defaultDateTimeFormat);
          case "duration":
            return renderMinimalDuration(wrapped.value);
        }
      }
      Values2.toString = toString;
      function wrapValue(val) {
        if (isNull(val))
          return { type: "null", value: val };
        else if (isNumber2(val))
          return { type: "number", value: val };
        else if (isString2(val))
          return { type: "string", value: val };
        else if (isBoolean(val))
          return { type: "boolean", value: val };
        else if (isDuration(val))
          return { type: "duration", value: val };
        else if (isDate2(val))
          return { type: "date", value: val };
        else if (isWidget(val))
          return { type: "widget", value: val };
        else if (isArray(val))
          return { type: "array", value: val };
        else if (isLink(val))
          return { type: "link", value: val };
        else if (isFunction(val))
          return { type: "function", value: val };
        else if (isHtml(val))
          return { type: "html", value: val };
        else if (isObject(val))
          return { type: "object", value: val };
        else
          return void 0;
      }
      Values2.wrapValue = wrapValue;
      function mapLeaves(val, func) {
        if (isObject(val)) {
          let result = {};
          for (let [key, value] of Object.entries(val))
            result[key] = mapLeaves(value, func);
          return result;
        } else if (isArray(val)) {
          let result = [];
          for (let value of val)
            result.push(mapLeaves(value, func));
          return result;
        } else {
          return func(val);
        }
      }
      Values2.mapLeaves = mapLeaves;
      function compareValue(val1, val2, linkNormalizer) {
        var _a, _b;
        if (val1 === void 0)
          val1 = null;
        if (val2 === void 0)
          val2 = null;
        if (val1 === null && val2 === null)
          return 0;
        else if (val1 === null)
          return -1;
        else if (val2 === null)
          return 1;
        let wrap1 = wrapValue(val1);
        let wrap2 = wrapValue(val2);
        if (wrap1 === void 0 && wrap2 === void 0)
          return 0;
        else if (wrap1 === void 0)
          return -1;
        else if (wrap2 === void 0)
          return 1;
        if (wrap1.type != wrap2.type)
          return wrap1.type.localeCompare(wrap2.type);
        if (wrap1.value === wrap2.value)
          return 0;
        switch (wrap1.type) {
          case "string":
            return wrap1.value.localeCompare(wrap2.value);
          case "number":
            if (wrap1.value < wrap2.value)
              return -1;
            else if (wrap1.value == wrap2.value)
              return 0;
            return 1;
          case "null":
            return 0;
          case "boolean":
            if (wrap1.value == wrap2.value)
              return 0;
            else
              return wrap1.value ? 1 : -1;
          case "link":
            let link1 = wrap1.value;
            let link2 = wrap2.value;
            let normalize = linkNormalizer !== null && linkNormalizer !== void 0 ? linkNormalizer : (x) => x;
            let pathCompare = normalize(link1.path).localeCompare(normalize(link2.path));
            if (pathCompare != 0)
              return pathCompare;
            let typeCompare = link1.type.localeCompare(link2.type);
            if (typeCompare != 0)
              return typeCompare;
            if (link1.subpath && !link2.subpath)
              return 1;
            if (!link1.subpath && link2.subpath)
              return -1;
            if (!link1.subpath && !link2.subpath)
              return 0;
            return ((_a = link1.subpath) !== null && _a !== void 0 ? _a : "").localeCompare((_b = link2.subpath) !== null && _b !== void 0 ? _b : "");
          case "date":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "duration":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "array":
            let f1 = wrap1.value;
            let f2 = wrap2.value;
            for (let index = 0; index < Math.min(f1.length, f2.length); index++) {
              let comp = compareValue(f1[index], f2[index]);
              if (comp != 0)
                return comp;
            }
            return f1.length - f2.length;
          case "object":
            let o1 = wrap1.value;
            let o2 = wrap2.value;
            let k1 = Array.from(Object.keys(o1));
            let k2 = Array.from(Object.keys(o2));
            k1.sort();
            k2.sort();
            let keyCompare = compareValue(k1, k2);
            if (keyCompare != 0)
              return keyCompare;
            for (let key of k1) {
              let comp = compareValue(o1[key], o2[key]);
              if (comp != 0)
                return comp;
            }
            return 0;
          case "widget":
          case "html":
          case "function":
            return 0;
        }
      }
      Values2.compareValue = compareValue;
      function typeOf(val) {
        var _a;
        return (_a = wrapValue(val)) === null || _a === void 0 ? void 0 : _a.type;
      }
      Values2.typeOf = typeOf;
      function isTruthy(field) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return false;
        switch (wrapped.type) {
          case "number":
            return wrapped.value != 0;
          case "string":
            return wrapped.value.length > 0;
          case "boolean":
            return wrapped.value;
          case "link":
            return !!wrapped.value.path;
          case "date":
            return wrapped.value.toMillis() != 0;
          case "duration":
            return wrapped.value.as("seconds") != 0;
          case "object":
            return Object.keys(wrapped.value).length > 0;
          case "array":
            return wrapped.value.length > 0;
          case "null":
            return false;
          case "html":
          case "widget":
          case "function":
            return true;
        }
      }
      Values2.isTruthy = isTruthy;
      function deepCopy(field) {
        if (field === null || field === void 0)
          return field;
        if (Values2.isArray(field)) {
          return [].concat(field.map((v) => deepCopy(v)));
        } else if (Values2.isObject(field)) {
          let result = {};
          for (let [key, value] of Object.entries(field))
            result[key] = deepCopy(value);
          return result;
        } else {
          return field;
        }
      }
      Values2.deepCopy = deepCopy;
      function isString2(val) {
        return typeof val == "string";
      }
      Values2.isString = isString2;
      function isNumber2(val) {
        return typeof val == "number";
      }
      Values2.isNumber = isNumber2;
      function isDate2(val) {
        return val instanceof DateTime_1;
      }
      Values2.isDate = isDate2;
      function isDuration(val) {
        return val instanceof Duration_1;
      }
      Values2.isDuration = isDuration;
      function isNull(val) {
        return val === null || val === void 0;
      }
      Values2.isNull = isNull;
      function isArray(val) {
        return Array.isArray(val);
      }
      Values2.isArray = isArray;
      function isBoolean(val) {
        return typeof val === "boolean";
      }
      Values2.isBoolean = isBoolean;
      function isLink(val) {
        return val instanceof Link;
      }
      Values2.isLink = isLink;
      function isWidget(val) {
        return val instanceof Widget;
      }
      Values2.isWidget = isWidget;
      function isHtml(val) {
        if (typeof HTMLElement !== "undefined") {
          return val instanceof HTMLElement;
        } else {
          return false;
        }
      }
      Values2.isHtml = isHtml;
      function isObject(val) {
        return typeof val == "object" && !isHtml(val) && !isWidget(val) && !isArray(val) && !isDuration(val) && !isDate2(val) && !isLink(val) && val !== void 0 && !isNull(val);
      }
      Values2.isObject = isObject;
      function isFunction(val) {
        return typeof val == "function";
      }
      Values2.isFunction = isFunction;
    })(Values || (Values = {}));
    var Groupings;
    (function(Groupings2) {
      function isElementGroup(entry) {
        return Values.isObject(entry) && Object.keys(entry).length == 2 && "key" in entry && "rows" in entry;
      }
      Groupings2.isElementGroup = isElementGroup;
      function isGrouping(entry) {
        for (let element of entry)
          if (!isElementGroup(element))
            return false;
        return true;
      }
      Groupings2.isGrouping = isGrouping;
      function count(elements) {
        if (isGrouping(elements)) {
          let result = 0;
          for (let subgroup of elements)
            result += count(subgroup.rows);
          return result;
        } else {
          return elements.length;
        }
      }
      Groupings2.count = count;
    })(Groupings || (Groupings = {}));
    var Link = class {
      constructor(fields) {
        Object.assign(this, fields);
      }
      static file(path, embed = false, display) {
        return new Link({
          path,
          embed,
          display,
          subpath: void 0,
          type: "file"
        });
      }
      static infer(linkpath, embed = false, display) {
        if (linkpath.includes("#^")) {
          let split = linkpath.split("#^");
          return Link.block(split[0], split[1], embed, display);
        } else if (linkpath.includes("#")) {
          let split = linkpath.split("#");
          return Link.header(split[0], split[1], embed, display);
        } else
          return Link.file(linkpath, embed, display);
      }
      static header(path, header, embed, display) {
        return new Link({
          path,
          embed,
          display,
          subpath: normalizeHeaderForLink(header),
          type: "header"
        });
      }
      static block(path, blockId, embed, display) {
        return new Link({
          path,
          embed,
          display,
          subpath: blockId,
          type: "block"
        });
      }
      static fromObject(object) {
        return new Link(object);
      }
      equals(other) {
        if (other == void 0 || other == null)
          return false;
        return this.path == other.path && this.type == other.type && this.subpath == other.subpath;
      }
      toString() {
        return this.markdown();
      }
      toObject() {
        return { path: this.path, type: this.type, subpath: this.subpath, display: this.display, embed: this.embed };
      }
      withPath(path) {
        return new Link(Object.assign({}, this, { path }));
      }
      withDisplay(display) {
        return new Link(Object.assign({}, this, { display }));
      }
      withHeader(header) {
        return Link.header(this.path, header, this.embed, this.display);
      }
      toFile() {
        return Link.file(this.path, this.embed, this.display);
      }
      toEmbed() {
        if (this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = true;
          return link;
        }
      }
      fromEmbed() {
        if (!this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = false;
          return link;
        }
      }
      markdown() {
        let result = (this.embed ? "!" : "") + "[[" + this.obsidianLink();
        if (this.display) {
          result += "|" + this.display;
        } else {
          result += "|" + getFileTitle(this.path);
          if (this.type == "header" || this.type == "block")
            result += " > " + this.subpath;
        }
        result += "]]";
        return result;
      }
      obsidianLink() {
        var _a, _b;
        const escaped = this.path.replace("|", "\\|");
        if (this.type == "header")
          return escaped + "#" + ((_a = this.subpath) === null || _a === void 0 ? void 0 : _a.replace("|", "\\|"));
        if (this.type == "block")
          return escaped + "#^" + ((_b = this.subpath) === null || _b === void 0 ? void 0 : _b.replace("|", "\\|"));
        else
          return escaped;
      }
      fileName() {
        return getFileTitle(this.path).replace(".md", "");
      }
    };
    var Widget = class {
      constructor($widget) {
        this.$widget = $widget;
      }
    };
    var ListPairWidget = class extends Widget {
      constructor(key, value) {
        super("dataview:list-pair");
        this.key = key;
        this.value = value;
      }
      markdown() {
        return `${Values.toString(this.key)}: ${Values.toString(this.value)}`;
      }
    };
    var ExternalLinkWidget = class extends Widget {
      constructor(url, display) {
        super("dataview:external-link");
        this.url = url;
        this.display = display;
      }
      markdown() {
        var _a;
        return `[${(_a = this.display) !== null && _a !== void 0 ? _a : this.url}](${this.url})`;
      }
    };
    var Widgets;
    (function(Widgets2) {
      function listPair(key, value) {
        return new ListPairWidget(key, value);
      }
      Widgets2.listPair = listPair;
      function externalLink(url, display) {
        return new ExternalLinkWidget(url, display);
      }
      Widgets2.externalLink = externalLink;
      function isListPair(widget) {
        return widget.$widget === "dataview:list-pair";
      }
      Widgets2.isListPair = isListPair;
      function isExternalLink(widget) {
        return widget.$widget === "dataview:external-link";
      }
      Widgets2.isExternalLink = isExternalLink;
      function isBuiltin(widget) {
        return isListPair(widget) || isExternalLink(widget);
      }
      Widgets2.isBuiltin = isBuiltin;
    })(Widgets || (Widgets = {}));
    var Fields;
    (function(Fields2) {
      function variable(name) {
        return { type: "variable", name };
      }
      Fields2.variable = variable;
      function literal(value) {
        return { type: "literal", value };
      }
      Fields2.literal = literal;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Fields2.binaryOp = binaryOp;
      function index(obj, index2) {
        return { type: "index", object: obj, index: index2 };
      }
      Fields2.index = index;
      function indexVariable(name) {
        let parts = name.split(".");
        let result = Fields2.variable(parts[0]);
        for (let index2 = 1; index2 < parts.length; index2++) {
          result = Fields2.index(result, Fields2.literal(parts[index2]));
        }
        return result;
      }
      Fields2.indexVariable = indexVariable;
      function lambda(args, value) {
        return { type: "lambda", arguments: args, value };
      }
      Fields2.lambda = lambda;
      function func(func2, args) {
        return { type: "function", func: func2, arguments: args };
      }
      Fields2.func = func;
      function list(values) {
        return { type: "list", values };
      }
      Fields2.list = list;
      function object(values) {
        return { type: "object", values };
      }
      Fields2.object = object;
      function negate(child) {
        return { type: "negated", child };
      }
      Fields2.negate = negate;
      function isCompareOp(op) {
        return op == "<=" || op == "<" || op == ">" || op == ">=" || op == "!=" || op == "=";
      }
      Fields2.isCompareOp = isCompareOp;
      Fields2.NULL = Fields2.literal(null);
    })(Fields || (Fields = {}));
    var Sources;
    (function(Sources2) {
      function tag(tag2) {
        return { type: "tag", tag: tag2 };
      }
      Sources2.tag = tag;
      function csv(path) {
        return { type: "csv", path };
      }
      Sources2.csv = csv;
      function folder(prefix) {
        return { type: "folder", folder: prefix };
      }
      Sources2.folder = folder;
      function link(file, incoming) {
        return { type: "link", file, direction: incoming ? "incoming" : "outgoing" };
      }
      Sources2.link = link;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Sources2.binaryOp = binaryOp;
      function and(left, right) {
        return { type: "binaryop", left, op: "&", right };
      }
      Sources2.and = and;
      function or(left, right) {
        return { type: "binaryop", left, op: "|", right };
      }
      Sources2.or = or;
      function negate(child) {
        return { type: "negate", child };
      }
      Sources2.negate = negate;
      function empty() {
        return { type: "empty" };
      }
      Sources2.empty = empty;
    })(Sources || (Sources = {}));
    var EMOJI_REGEX = new RegExp(emojiRegex(), "");
    var DURATION_TYPES = {
      year: Duration_1.fromObject({ years: 1 }),
      years: Duration_1.fromObject({ years: 1 }),
      yr: Duration_1.fromObject({ years: 1 }),
      yrs: Duration_1.fromObject({ years: 1 }),
      month: Duration_1.fromObject({ months: 1 }),
      months: Duration_1.fromObject({ months: 1 }),
      mo: Duration_1.fromObject({ months: 1 }),
      mos: Duration_1.fromObject({ months: 1 }),
      week: Duration_1.fromObject({ weeks: 1 }),
      weeks: Duration_1.fromObject({ weeks: 1 }),
      wk: Duration_1.fromObject({ weeks: 1 }),
      wks: Duration_1.fromObject({ weeks: 1 }),
      w: Duration_1.fromObject({ weeks: 1 }),
      day: Duration_1.fromObject({ days: 1 }),
      days: Duration_1.fromObject({ days: 1 }),
      d: Duration_1.fromObject({ days: 1 }),
      hour: Duration_1.fromObject({ hours: 1 }),
      hours: Duration_1.fromObject({ hours: 1 }),
      hr: Duration_1.fromObject({ hours: 1 }),
      hrs: Duration_1.fromObject({ hours: 1 }),
      h: Duration_1.fromObject({ hours: 1 }),
      minute: Duration_1.fromObject({ minutes: 1 }),
      minutes: Duration_1.fromObject({ minutes: 1 }),
      min: Duration_1.fromObject({ minutes: 1 }),
      mins: Duration_1.fromObject({ minutes: 1 }),
      m: Duration_1.fromObject({ minutes: 1 }),
      second: Duration_1.fromObject({ seconds: 1 }),
      seconds: Duration_1.fromObject({ seconds: 1 }),
      sec: Duration_1.fromObject({ seconds: 1 }),
      secs: Duration_1.fromObject({ seconds: 1 }),
      s: Duration_1.fromObject({ seconds: 1 })
    };
    var DATE_SHORTHANDS = {
      now: () => DateTime_1.local(),
      today: () => DateTime_1.local().startOf("day"),
      yesterday: () => DateTime_1.local().startOf("day").minus(Duration_1.fromObject({ days: 1 })),
      tomorrow: () => DateTime_1.local().startOf("day").plus(Duration_1.fromObject({ days: 1 })),
      sow: () => DateTime_1.local().startOf("week"),
      "start-of-week": () => DateTime_1.local().startOf("week"),
      eow: () => DateTime_1.local().endOf("week"),
      "end-of-week": () => DateTime_1.local().endOf("week"),
      soy: () => DateTime_1.local().startOf("year"),
      "start-of-year": () => DateTime_1.local().startOf("year"),
      eoy: () => DateTime_1.local().endOf("year"),
      "end-of-year": () => DateTime_1.local().endOf("year"),
      som: () => DateTime_1.local().startOf("month"),
      "start-of-month": () => DateTime_1.local().startOf("month"),
      eom: () => DateTime_1.local().endOf("month"),
      "end-of-month": () => DateTime_1.local().endOf("month")
    };
    var KEYWORDS = ["FROM", "WHERE", "LIMIT", "GROUP", "FLATTEN"];
    function splitOnUnescapedPipe(link) {
      let pipe = -1;
      while ((pipe = link.indexOf("|", pipe + 1)) >= 0) {
        if (pipe > 0 && link[pipe - 1] == "\\")
          continue;
        return [link.substring(0, pipe).replace(/\\\|/g, "|"), link.substring(pipe + 1)];
      }
      return [link.replace(/\\\|/g, "|"), void 0];
    }
    function parseInnerLink(rawlink) {
      let [link, display] = splitOnUnescapedPipe(rawlink);
      return Link.infer(link, false, display);
    }
    function createBinaryParser(child, sep, combine) {
      return parsimmon_umd_min.exports.seqMap(child, parsimmon_umd_min.exports.seq(parsimmon_umd_min.exports.optWhitespace, sep, parsimmon_umd_min.exports.optWhitespace, child).many(), (first, rest) => {
        if (rest.length == 0)
          return first;
        let node = combine(first, rest[0][1], rest[0][3]);
        for (let index = 1; index < rest.length; index++) {
          node = combine(node, rest[index][1], rest[index][3]);
        }
        return node;
      });
    }
    function chainOpt(base, ...funcs) {
      return parsimmon_umd_min.exports.custom((success, failure) => {
        return (input, i) => {
          let result = base._(input, i);
          if (!result.status)
            return result;
          for (let func of funcs) {
            let next = func(result.value)._(input, result.index);
            if (!next.status)
              return result;
            result = next;
          }
          return result;
        };
      });
    }
    var EXPRESSION = parsimmon_umd_min.exports.createLanguage({
      number: (q) => parsimmon_umd_min.exports.regexp(/-?[0-9]+(\.[0-9]+)?/).map((str) => Number.parseFloat(str)).desc("number"),
      string: (q) => parsimmon_umd_min.exports.string('"').then(parsimmon_umd_min.exports.alt(q.escapeCharacter, parsimmon_umd_min.exports.noneOf('"\\')).atLeast(0).map((chars) => chars.join(""))).skip(parsimmon_umd_min.exports.string('"')).desc("string"),
      escapeCharacter: (_) => parsimmon_umd_min.exports.string("\\").then(parsimmon_umd_min.exports.any).map((escaped) => {
        if (escaped === '"')
          return '"';
        if (escaped === "\\")
          return "\\";
        else
          return "\\" + escaped;
      }),
      bool: (_) => parsimmon_umd_min.exports.regexp(/true|false|True|False/).map((str) => str.toLowerCase() == "true").desc("boolean ('true' or 'false')"),
      tag: (_) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("#"), parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/[\p{Letter}0-9_/-]/u).desc("text"), parsimmon_umd_min.exports.regexp(EMOJI_REGEX).desc("text")).many(), (start, rest) => start + rest.join("")).desc("tag ('#hello/stuff')"),
      identifier: (_) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/\p{Letter}/u), parsimmon_umd_min.exports.regexp(EMOJI_REGEX).desc("text")), parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/[0-9\p{Letter}_-]/u), parsimmon_umd_min.exports.regexp(EMOJI_REGEX).desc("text")).many(), (first, rest) => first + rest.join("")).desc("variable identifier"),
      link: (_) => parsimmon_umd_min.exports.regexp(/\[\[([^\[\]]*?)\]\]/u, 1).map((linkInner) => parseInnerLink(linkInner)).desc("file link"),
      embedLink: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("!").atMost(1), q.link, (p, l2) => {
        if (p.length > 0)
          l2.embed = true;
        return l2;
      }).desc("file link"),
      binaryPlusMinus: (_) => parsimmon_umd_min.exports.regexp(/\+|-/).map((str) => str).desc("'+' or '-'"),
      binaryMulDiv: (_) => parsimmon_umd_min.exports.regexp(/\*|\/|%/).map((str) => str).desc("'*' or '/' or '%'"),
      binaryCompareOp: (_) => parsimmon_umd_min.exports.regexp(/>=|<=|!=|>|<|=/).map((str) => str).desc("'>=' or '<=' or '!=' or '=' or '>' or '<'"),
      binaryBooleanOp: (_) => parsimmon_umd_min.exports.regexp(/and|or|&|\|/i).map((str) => {
        if (str.toLowerCase() == "and")
          return "&";
        else if (str.toLowerCase() == "or")
          return "|";
        else
          return str;
      }).desc("'and' or 'or'"),
      rootDate: (_) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/\d{4}/), parsimmon_umd_min.exports.string("-"), parsimmon_umd_min.exports.regexp(/\d{2}/), (year, _2, month) => {
        return DateTime_1.fromObject({ year: Number.parseInt(year), month: Number.parseInt(month) });
      }).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      dateShorthand: (_) => parsimmon_umd_min.exports.alt(...Object.keys(DATE_SHORTHANDS).sort((a, b) => b.length - a.length).map(parsimmon_umd_min.exports.string)),
      date: (q) => chainOpt(q.rootDate, (ym) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("-"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_, day) => ym.set({ day: Number.parseInt(day) })), (ymd) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("T"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_, hour) => ymd.set({ hour: Number.parseInt(hour) })), (ymdh) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string(":"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_, minute) => ymdh.set({ minute: Number.parseInt(minute) })), (ymdhm) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string(":"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_, second) => ymdhm.set({ second: Number.parseInt(second) })), (ymdhms) => parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("."), parsimmon_umd_min.exports.regexp(/\d{3}/), (_, millisecond) => ymdhms.set({ millisecond: Number.parseInt(millisecond) })), parsimmon_umd_min.exports.succeed(ymdhms)), (dt) => parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("+").or(parsimmon_umd_min.exports.string("-")), parsimmon_umd_min.exports.regexp(/\d{1,2}(:\d{2})?/), (pm, hr) => dt.setZone("UTC" + pm + hr, { keepLocalTime: true })), parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("Z"), () => dt.setZone("utc", { keepLocalTime: true })), parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("["), parsimmon_umd_min.exports.regexp(/[0-9A-Za-z+-\/]+/u), parsimmon_umd_min.exports.string("]"), (_a, zone, _b) => dt.setZone(zone, { keepLocalTime: true })))).assert((dt) => dt.isValid, "valid date").desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      datePlus: (q) => parsimmon_umd_min.exports.alt(q.dateShorthand.map((d) => DATE_SHORTHANDS[d]()), q.date).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS] or in shorthand"),
      durationType: (_) => parsimmon_umd_min.exports.alt(...Object.keys(DURATION_TYPES).sort((a, b) => b.length - a.length).map(parsimmon_umd_min.exports.string)),
      duration: (q) => parsimmon_umd_min.exports.seqMap(q.number, parsimmon_umd_min.exports.optWhitespace, q.durationType, (count, _, t) => DURATION_TYPES[t].mapUnits((x) => x * count)).sepBy1(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace).or(parsimmon_umd_min.exports.optWhitespace)).map((durations) => durations.reduce((p, c) => p.plus(c))).desc("duration like 4hr2min"),
      rawNull: (_) => parsimmon_umd_min.exports.string("null"),
      tagSource: (q) => q.tag.map((tag) => Sources.tag(tag)),
      csvSource: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("csv(").skip(parsimmon_umd_min.exports.optWhitespace), q.string, parsimmon_umd_min.exports.string(")"), (_1, path, _2) => Sources.csv(path)),
      linkIncomingSource: (q) => q.link.map((link) => Sources.link(link.path, true)),
      linkOutgoingSource: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("outgoing(").skip(parsimmon_umd_min.exports.optWhitespace), q.link, parsimmon_umd_min.exports.string(")"), (_1, link, _2) => Sources.link(link.path, false)),
      folderSource: (q) => q.string.map((str) => Sources.folder(str)),
      parensSource: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("("), parsimmon_umd_min.exports.optWhitespace, q.source, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (_1, _2, field, _3, _4) => field),
      negateSource: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.string("-"), parsimmon_umd_min.exports.string("!")), q.atomSource, (_, source) => Sources.negate(source)),
      atomSource: (q) => parsimmon_umd_min.exports.alt(q.parensSource, q.negateSource, q.linkOutgoingSource, q.linkIncomingSource, q.folderSource, q.tagSource, q.csvSource),
      binaryOpSource: (q) => createBinaryParser(q.atomSource, q.binaryBooleanOp.map((s2) => s2), Sources.binaryOp),
      source: (q) => q.binaryOpSource,
      variableField: (q) => q.identifier.chain((r) => {
        if (KEYWORDS.includes(r.toUpperCase())) {
          return parsimmon_umd_min.exports.fail("Variable fields cannot be a keyword (" + KEYWORDS.join(" or ") + ")");
        } else {
          return parsimmon_umd_min.exports.succeed(Fields.variable(r));
        }
      }).desc("variable"),
      numberField: (q) => q.number.map((val) => Fields.literal(val)).desc("number"),
      stringField: (q) => q.string.map((val) => Fields.literal(val)).desc("string"),
      boolField: (q) => q.bool.map((val) => Fields.literal(val)).desc("boolean"),
      dateField: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("date("), parsimmon_umd_min.exports.optWhitespace, q.datePlus, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (prefix, _1, date, _2, postfix) => Fields.literal(date)).desc("date"),
      durationField: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("dur("), parsimmon_umd_min.exports.optWhitespace, q.duration, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (prefix, _1, dur, _2, postfix) => Fields.literal(dur)).desc("duration"),
      nullField: (q) => q.rawNull.map((_) => Fields.NULL),
      linkField: (q) => q.link.map((f) => Fields.literal(f)),
      listField: (q) => q.field.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)).wrap(parsimmon_umd_min.exports.string("[").skip(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.optWhitespace.then(parsimmon_umd_min.exports.string("]"))).map((l2) => Fields.list(l2)).desc("list ('[1, 2, 3]')"),
      objectField: (q) => parsimmon_umd_min.exports.seqMap(q.identifier.or(q.string), parsimmon_umd_min.exports.string(":").trim(parsimmon_umd_min.exports.optWhitespace), q.field, (name, _sep, value) => {
        return { name, value };
      }).sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)).wrap(parsimmon_umd_min.exports.string("{").skip(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.optWhitespace.then(parsimmon_umd_min.exports.string("}"))).map((vals) => {
        let res = {};
        for (let entry of vals)
          res[entry.name] = entry.value;
        return Fields.object(res);
      }).desc("object ('{ a: 1, b: 2 }')"),
      atomInlineField: (q) => parsimmon_umd_min.exports.alt(q.date, q.duration.map((d) => normalizeDuration(d)), q.string, q.tag, q.embedLink, q.bool, q.number, q.rawNull),
      inlineFieldList: (q) => q.atomInlineField.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace).lookahead(q.atomInlineField)),
      inlineField: (q) => parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.seqMap(q.atomInlineField, parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace), q.inlineFieldList, (f, _s, l2) => [f].concat(l2)), q.atomInlineField),
      atomField: (q) => parsimmon_umd_min.exports.alt(q.embedLink.map((l2) => Fields.literal(l2)), q.negatedField, q.linkField, q.listField, q.objectField, q.lambdaField, q.parensField, q.boolField, q.numberField, q.stringField, q.dateField, q.durationField, q.nullField, q.variableField),
      indexField: (q) => parsimmon_umd_min.exports.seqMap(q.atomField, parsimmon_umd_min.exports.alt(q.dotPostfix, q.indexPostfix, q.functionPostfix).many(), (obj, postfixes) => {
        let result = obj;
        for (let post of postfixes) {
          switch (post.type) {
            case "dot":
              result = Fields.index(result, Fields.literal(post.field));
              break;
            case "index":
              result = Fields.index(result, post.field);
              break;
            case "function":
              result = Fields.func(result, post.fields);
              break;
          }
        }
        return result;
      }),
      negatedField: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("!"), q.indexField, (_, field) => Fields.negate(field)).desc("negated field"),
      parensField: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("("), parsimmon_umd_min.exports.optWhitespace, q.field, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (_1, _2, field, _3, _4) => field),
      lambdaField: (q) => parsimmon_umd_min.exports.seqMap(q.identifier.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)).wrap(parsimmon_umd_min.exports.string("(").trim(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.string(")").trim(parsimmon_umd_min.exports.optWhitespace)), parsimmon_umd_min.exports.string("=>").trim(parsimmon_umd_min.exports.optWhitespace), q.field, (ident, _ignore, value) => {
        return { type: "lambda", arguments: ident, value };
      }),
      dotPostfix: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("."), q.identifier, (_, field) => {
        return { type: "dot", field };
      }),
      indexPostfix: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("["), parsimmon_umd_min.exports.optWhitespace, q.field, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string("]"), (_, _2, field, _3, _4) => {
        return { type: "index", field };
      }),
      functionPostfix: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("("), parsimmon_umd_min.exports.optWhitespace, q.field.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)), parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (_, _1, fields, _2, _3) => {
        return { type: "function", fields };
      }),
      binaryMulDivField: (q) => createBinaryParser(q.indexField, q.binaryMulDiv, Fields.binaryOp),
      binaryPlusMinusField: (q) => createBinaryParser(q.binaryMulDivField, q.binaryPlusMinus, Fields.binaryOp),
      binaryCompareField: (q) => createBinaryParser(q.binaryPlusMinusField, q.binaryCompareOp, Fields.binaryOp),
      binaryBooleanField: (q) => createBinaryParser(q.binaryCompareField, q.binaryBooleanOp, Fields.binaryOp),
      binaryOpField: (q) => q.binaryBooleanField,
      field: (q) => q.binaryOpField
    });
    function parseField(text) {
      try {
        return Result.success(EXPRESSION.field.tryParse(text));
      } catch (error) {
        return Result.failure("" + error);
      }
    }
    var QueryFields;
    (function(QueryFields2) {
      function named(name, field) {
        return { name, field };
      }
      QueryFields2.named = named;
      function sortBy(field, dir) {
        return { field, direction: dir };
      }
      QueryFields2.sortBy = sortBy;
    })(QueryFields || (QueryFields = {}));
    function captureRaw(base) {
      return parsimmon_umd_min.exports.custom((success, failure) => {
        return (input, i) => {
          let result = base._(input, i);
          if (!result.status)
            return result;
          return Object.assign({}, result, { value: [result.value, input.substring(i, result.index)] });
        };
      });
    }
    function stripNewlines(text) {
      return text.split(/[\r\n]+/).map((t) => t.trim()).join("");
    }
    var QUERY_LANGUAGE = parsimmon_umd_min.exports.createLanguage({
      queryType: (q) => parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/TABLE|LIST|TASK|CALENDAR/i)).map((str) => str.toLowerCase()).desc("query type ('TABLE', 'LIST', 'TASK', or 'CALENDAR')"),
      explicitNamedField: (q) => parsimmon_umd_min.exports.seqMap(EXPRESSION.field.skip(parsimmon_umd_min.exports.whitespace), parsimmon_umd_min.exports.regexp(/AS/i).skip(parsimmon_umd_min.exports.whitespace), EXPRESSION.identifier.or(EXPRESSION.string), (field, _as, ident) => QueryFields.named(ident, field)),
      namedField: (q) => parsimmon_umd_min.exports.alt(q.explicitNamedField, captureRaw(EXPRESSION.field).map(([value, text]) => QueryFields.named(stripNewlines(text), value))),
      sortField: (q) => parsimmon_umd_min.exports.seqMap(EXPRESSION.field.skip(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.regexp(/ASCENDING|DESCENDING|ASC|DESC/i).atMost(1), (field, dir) => {
        let direction = dir.length == 0 ? "ascending" : dir[0].toLowerCase();
        if (direction == "desc")
          direction = "descending";
        if (direction == "asc")
          direction = "ascending";
        return {
          field,
          direction
        };
      }),
      headerClause: (q) => q.queryType.skip(parsimmon_umd_min.exports.whitespace).chain((qtype) => {
        switch (qtype) {
          case "table":
            return parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_min.exports.optWhitespace).atMost(1), parsimmon_umd_min.exports.sepBy(q.namedField, parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)), (withoutId, fields) => {
              return { type: "table", fields, showId: withoutId.length == 0 };
            });
          case "list":
            return parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_min.exports.optWhitespace).atMost(1), EXPRESSION.field.atMost(1), (withoutId, format) => {
              return {
                type: "list",
                format: format.length == 1 ? format[0] : void 0,
                showId: withoutId.length == 0
              };
            });
          case "task":
            return parsimmon_umd_min.exports.succeed({ type: "task" });
          case "calendar":
            return parsimmon_umd_min.exports.seqMap(q.namedField, (field) => {
              return {
                type: "calendar",
                showId: true,
                field
              };
            });
          default:
            return parsimmon_umd_min.exports.fail(`Unrecognized query type '${qtype}'`);
        }
      }).desc("TABLE or LIST or TASK or CALENDAR"),
      fromClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/FROM/i), parsimmon_umd_min.exports.whitespace, EXPRESSION.source, (_1, _2, source) => source),
      whereClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/WHERE/i), parsimmon_umd_min.exports.whitespace, EXPRESSION.field, (where, _, field) => {
        return { type: "where", clause: field };
      }).desc("WHERE <expression>"),
      sortByClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/SORT/i), parsimmon_umd_min.exports.whitespace, q.sortField.sepBy1(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)), (sort, _1, fields) => {
        return { type: "sort", fields };
      }).desc("SORT field [ASC/DESC]"),
      limitClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/LIMIT/i), parsimmon_umd_min.exports.whitespace, EXPRESSION.field, (limit, _1, field) => {
        return { type: "limit", amount: field };
      }).desc("LIMIT <value>"),
      flattenClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/FLATTEN/i).skip(parsimmon_umd_min.exports.whitespace), q.namedField, (_, field) => {
        return { type: "flatten", field };
      }).desc("FLATTEN <value> [AS <name>]"),
      groupByClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/GROUP BY/i).skip(parsimmon_umd_min.exports.whitespace), q.namedField, (_, field) => {
        return { type: "group", field };
      }).desc("GROUP BY <value> [AS <name>]"),
      clause: (q) => parsimmon_umd_min.exports.alt(q.fromClause, q.whereClause, q.sortByClause, q.limitClause, q.groupByClause, q.flattenClause),
      query: (q) => parsimmon_umd_min.exports.seqMap(q.headerClause.trim(parsimmon_umd_min.exports.optWhitespace), q.fromClause.trim(parsimmon_umd_min.exports.optWhitespace).atMost(1), q.clause.trim(parsimmon_umd_min.exports.optWhitespace).many(), (header, from, clauses) => {
        return {
          header,
          source: from.length == 0 ? Sources.folder("") : from[0],
          operations: clauses,
          settings: DEFAULT_QUERY_SETTINGS
        };
      })
    });
    var getAPI3 = (app2) => {
      var _a;
      if (app2)
        return (_a = app2.plugins.plugins.dataview) === null || _a === void 0 ? void 0 : _a.api;
      else
        return window.DataviewAPI;
    };
    var isPluginEnabled = (app2) => app2.plugins.enabledPlugins.has("dataview");
    exports.DATE_SHORTHANDS = DATE_SHORTHANDS;
    exports.DURATION_TYPES = DURATION_TYPES;
    exports.EXPRESSION = EXPRESSION;
    exports.KEYWORDS = KEYWORDS;
    exports.QUERY_LANGUAGE = QUERY_LANGUAGE;
    exports.getAPI = getAPI3;
    exports.isPluginEnabled = isPluginEnabled;
    exports.parseField = parseField;
  }
});

// main.ts
__export(exports, {
  default: () => FileCookerPlugin
});
var import_obsidian28 = __toModule(require("obsidian"));

// src/action/delete-action.ts
var import_obsidian2 = __toModule(require("obsidian"));

// src/modal/delete-confirm-modal.ts
var import_obsidian = __toModule(require("obsidian"));
var DeleteConfirmModal = class extends import_obsidian.Modal {
  constructor(app2, resultArr) {
    super(app2);
    this.resultArr = resultArr;
  }
  onOpen() {
    return __async(this, null, function* () {
      const { contentEl } = this;
      contentEl.createEl("h1", { text: "Confirm Delete?" });
      if (this.resultArr.length == 0) {
        contentEl.createEl("div", { text: "No files found!" });
        new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Close").setCta().onClick(() => {
          this.close();
        }));
      } else {
        this.resultArr.forEach((info) => {
          contentEl.createEl("div", { text: info.path });
        });
        new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Confirm").setCta().onClick(() => {
          this.close();
          this.resultArr.forEach((info) => {
            this.app.vault.trash(info, true);
          });
          new import_obsidian.Notice("Delete Success!");
        })).addButton((btn) => btn.setButtonText("Cancel").setCta().onClick(() => {
          this.close();
          new import_obsidian.Notice("Delete Canceled!");
        }));
      }
    });
  }
};

// src/action/delete-action.ts
var DeleteAction = class {
  constructor(app2) {
    this.app = app2;
  }
  act(actionModels) {
    if (actionModels.length > 0) {
      let files = actionModels.map((model) => model.file);
      new DeleteConfirmModal(this.app, files).open();
    } else {
      new import_obsidian2.Notice("No Files Found!");
    }
  }
};

// src/action/edit-properties-action.ts
var import_obsidian4 = __toModule(require("obsidian"));

// src/modal/edit-properties-modal.ts
var import_obsidian3 = __toModule(require("obsidian"));
var EditPropertiesModal = class extends import_obsidian3.Modal {
  constructor(app2, resultArr) {
    super(app2);
    this.resultArr = resultArr;
    let tmpFlag = localStorage.getItem("overrideFlag");
    if (tmpFlag && tmpFlag == "true") {
      this.overrideFlag = true;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Edit Properties" });
    if (this.resultArr.length == 0) {
      contentEl.createEl("div", { text: "No files found!" });
      new import_obsidian3.Setting(contentEl).addButton((btn) => btn.setButtonText("Close").setCta().onClick(() => {
        this.close();
      }));
    } else {
      this.resultArr.forEach((info) => {
        contentEl.createEl("div", { text: info.path });
      });
      new import_obsidian3.Setting(contentEl).addText((txt) => txt.setPlaceholder("Properties Key").onChange((val) => {
        this.key = val;
      })).addText((txt) => txt.setPlaceholder("Properties Value").onChange((val) => {
        this.val = val;
      })).addToggle((toggle) => {
        toggle.setValue(this.overrideFlag);
        toggle.setTooltip("Override if exists!");
        toggle.onChange((val) => {
          localStorage.setItem("overrideFlag", val + "");
          this.overrideFlag = val;
        });
      });
      new import_obsidian3.Setting(contentEl).addButton((btn) => btn.setButtonText("Confirm").setCta().onClick(() => __async(this, null, function* () {
        if (this.key == null || this.key.trim() == "") {
          new import_obsidian3.Notice("Key could not be empty!");
          return;
        }
        if (this.val == null || this.val.trim() == "") {
          new import_obsidian3.Notice("Value could not be empty!");
          return;
        }
        this.close();
        for (let i = 0; i < this.resultArr.length; i++) {
          let info = this.resultArr[i];
          let _this = this;
          this.app.fileManager.processFrontMatter(info, (props) => {
            let _k = _this.key.trim();
            let _v = _this.val.trim();
            if (_k === "tags" || _k === "alias" || _k === "cssclasses") {
              let _vals = _v.split(",");
              if (!props[_k]) {
                props[_k] = [];
              } else if (!(props[_k] instanceof Array)) {
                props[_k] = props[_k].split(",");
              }
              _vals.forEach((_t) => {
                let it = _t.trim();
                if (it.indexOf("-") === 0) {
                  let _tv = it.substring(1, it.length);
                  let idx = -1;
                  for (let i2 = 0; i2 < props[_k].length; i2++) {
                    if (props[_k][i2] === _tv) {
                      idx = i2;
                      break;
                    }
                  }
                  delete props[_k][idx];
                } else {
                  props[_k].push(it);
                }
              });
            } else {
              if (_v === "-") {
                delete props[_k];
              } else if (_this.overrideFlag || !props[_k]) {
                props[_k] = _v;
              }
            }
          });
        }
        new import_obsidian3.Notice("Modify Property Success!");
      }))).addButton((btn) => btn.setButtonText("Cancel").setCta().onClick(() => {
        this.close();
        new import_obsidian3.Notice("Modify Property Canceled!");
      }));
    }
  }
};

// src/action/edit-properties-action.ts
var EditPropertiesAction = class {
  constructor(app2) {
    this.app = app2;
  }
  act(actionModels) {
    if (actionModels.length > 0) {
      let files = actionModels.map((model) => model.file);
      new EditPropertiesModal(this.app, files).open();
    } else {
      new import_obsidian4.Notice("No Files Found!");
    }
  }
};

// src/action/move-action.ts
var import_obsidian6 = __toModule(require("obsidian"));

// src/modal/move-confirm-modal.ts
var import_obsidian5 = __toModule(require("obsidian"));
var MoveConfirmModal = class extends import_obsidian5.Modal {
  constructor(app2, moveInfos) {
    super(app2);
    this.moveInfos = moveInfos;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Confirm Move/Copy?" });
    this.moveInfos.forEach((info) => {
      contentEl.createEl("div", { text: info.sourceFile.path + " -> " + info.targetDir + "/" + info.sourceFile.name });
    });
    new import_obsidian5.Setting(contentEl).addToggle((toggle) => {
      toggle.setTooltip("Copy instead!");
      toggle.onChange((val) => {
        this.copyFlag = val;
      });
    });
    new import_obsidian5.Setting(contentEl).addButton((btn) => btn.setButtonText("Confirm").setCta().onClick(() => __async(this, null, function* () {
      this.close();
      if (this.copyFlag) {
        for (const key in this.moveInfos) {
          let info = this.moveInfos[key];
          yield this.app.vault.copy(info.sourceFile, info.targetDir + "/" + info.sourceFile.name);
        }
        new import_obsidian5.Notice("Copy Success!");
      } else {
        for (const key in this.moveInfos) {
          let info = this.moveInfos[key];
          yield this.app.fileManager.renameFile(info.sourceFile, info.targetDir + "/" + info.sourceFile.name);
        }
        new import_obsidian5.Notice("Move Success!");
      }
    }))).addButton((btn) => btn.setButtonText("Cancel").setCta().onClick(() => {
      this.close();
      new import_obsidian5.Notice("Move Canceled!");
    }));
  }
};

// src/action/move-action.ts
var MoveAction = class {
  constructor(app2, targetPath) {
    this.app = app2;
    this.targetPath = targetPath;
  }
  act(actionModels) {
    const moveInfos = [];
    if (actionModels.length > 0) {
      actionModels.forEach((model) => {
        let ff = model.file;
        moveInfos.push({
          sourceFile: ff,
          targetDir: this.targetPath
        });
      });
      new MoveConfirmModal(this.app, moveInfos).open();
    } else {
      new import_obsidian6.Notice("No Files Found!");
    }
  }
};

// src/action/rename-action.ts
var import_obsidian9 = __toModule(require("obsidian"));

// src/modal/rename-modal.ts
var import_obsidian8 = __toModule(require("obsidian"));

// src/modal/rename-confirm-modal.ts
var import_obsidian7 = __toModule(require("obsidian"));

// src/utils/file-type-util.ts
function hasMarkdownSuffix(str) {
  return str.endsWith(".md") || str.endsWith(".MD") || str.endsWith(".Md") || str.endsWith(".mD");
}
function hasCanvasSuffix(str) {
  return str.endsWith(".canvas");
}

// src/modal/rename-confirm-modal.ts
var RenameConfirmModal = class extends import_obsidian7.Modal {
  constructor(app2, resultArr, prefix, suffix) {
    super(app2);
    this.resultArr = resultArr;
    this.prefix = prefix;
    this.suffix = suffix;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Rename Files" });
    this.resultArr.forEach((info) => {
      let name = this.newName(info.name);
      contentEl.createEl("div", { text: info.name + "->" + name });
    });
    new import_obsidian7.Setting(contentEl).addButton((btn) => btn.setButtonText("Confirm").setCta().onClick(() => __async(this, null, function* () {
      if ((this.prefix == null || this.prefix.trim() == "") && (this.suffix == null || this.suffix.trim() == "")) {
        new import_obsidian7.Notice("Prefix and Suffix could not be all empty!");
        return;
      }
      this.close();
      for (let i = 0; i < this.resultArr.length; i++) {
        let info = this.resultArr[i];
        let name = this.newName(info.name);
        yield this.app.fileManager.renameFile(info, info.parent.path + "/" + name);
      }
      new import_obsidian7.Notice("Rename Success!");
    }))).addButton((btn) => btn.setButtonText("Cancel").setCta().onClick(() => {
      this.close();
      new import_obsidian7.Notice("Rename Canceled!");
    }));
  }
  newName(name) {
    let tName = name + "";
    let suf = "";
    if (hasMarkdownSuffix(tName)) {
      tName = tName.replace(".md", "");
      suf = ".md";
    }
    if (this.prefix && this.prefix.trim() != "") {
      if (this.prefix.startsWith("-")) {
        let t = this.prefix.substring(1, this.prefix.length);
        if (tName.startsWith(t)) {
          tName = tName.substring(t.length, tName.length);
        }
      } else {
        tName = this.prefix + tName;
      }
    }
    if (this.suffix && this.suffix.trim() != "") {
      if (this.suffix.startsWith("-")) {
        let t = this.suffix.substring(1, this.suffix.length);
        if (tName.endsWith(t)) {
          tName = tName.substring(0, tName.length - t.length);
        }
      } else {
        tName = tName + this.suffix;
      }
    }
    return tName + suf;
  }
};

// src/modal/rename-modal.ts
var RenameModal = class extends import_obsidian8.Modal {
  constructor(app2, resultArr) {
    super(app2);
    this.resultArr = resultArr;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Rename Files" });
    if (this.resultArr.length == 0) {
      contentEl.createEl("div", { text: "No files found!" });
      new import_obsidian8.Setting(contentEl).addButton((btn) => btn.setButtonText("Close").setCta().onClick(() => {
        this.close();
      }));
    } else {
      this.resultArr.forEach((info) => {
        contentEl.createEl("div", { text: info.path });
      });
      new import_obsidian8.Setting(contentEl).addText((txt) => txt.setPlaceholder("Prefix").onChange((val) => {
        this.prefix = val;
      })).addText((txt) => txt.setPlaceholder("Suffix").onChange((val) => {
        this.suffix = val;
      }));
      new import_obsidian8.Setting(contentEl).addButton((btn) => btn.setButtonText("Confirm").setCta().onClick(() => __async(this, null, function* () {
        if ((this.prefix == null || this.prefix.trim() == "") && (this.suffix == null || this.suffix.trim() == "")) {
          new import_obsidian8.Notice("Prefix and Suffix could not be all empty!");
          return;
        }
        this.close();
        new RenameConfirmModal(this.app, this.resultArr, this.prefix, this.suffix).open();
      }))).addButton((btn) => btn.setButtonText("Cancel").setCta().onClick(() => {
        this.close();
        new import_obsidian8.Notice("Rename Canceled!");
      }));
    }
  }
};

// src/action/rename-action.ts
var RenameAction = class {
  constructor(app2) {
    this.app = app2;
  }
  act(actionModels) {
    if (actionModels.length > 0) {
      let files = actionModels.map((model) => model.file);
      new RenameModal(this.app, files).open();
    } else {
      new import_obsidian9.Notice("No Files Found!");
    }
  }
};

// src/action/sync-flomo-action.ts
var import_obsidian11 = __toModule(require("obsidian"));

// src/modal/sync-flomo-confirm-modal.ts
var import_obsidian10 = __toModule(require("obsidian"));
var import_node_fetch = __toModule(require_browser());
var SyncFlomoConfirmModal = class extends import_obsidian10.Modal {
  constructor(plugin, actionModels) {
    super(plugin.app);
    this.plugin = plugin;
    this.actionModels = actionModels;
  }
  onOpen() {
    return __async(this, null, function* () {
      const { contentEl } = this;
      contentEl.createEl("h1", { text: "Confirm Sync to flomo?" });
      if (this.actionModels.length == 0) {
        contentEl.createEl("div", { text: "No files found!" });
        new import_obsidian10.Setting(contentEl).addButton((btn) => btn.setButtonText("Close").setCta().onClick(() => {
          this.close();
        }));
      } else {
        this.actionModels.forEach((info) => {
          if (info.file != null) {
            contentEl.createEl("div", { text: info.file.path });
          } else {
            contentEl.createEl("div", { text: "Sync Selection" });
          }
        });
        new import_obsidian10.Setting(contentEl).addButton((btn) => btn.setButtonText("Confirm").setCta().onClick(() => __async(this, null, function* () {
          this.close();
          for (let i = 0; i < this.actionModels.length; i++) {
            let info = this.actionModels[i];
            let cont;
            if (info.file != null) {
              cont = yield this.app.vault.read(info.file);
            } else {
              cont = info.content;
            }
            const response = yield (0, import_node_fetch.default)(this.plugin.settings.flomoAPI, {
              method: "POST",
              body: JSON.stringify({
                content: cont
              }),
              headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
              }
            });
            if (!response.ok) {
              new import_obsidian10.Notice(`Sync to flomo Error!${response.text}[${response.status}]`);
              return;
            }
          }
          new import_obsidian10.Notice("Sync to flomo Success!");
        }))).addButton((btn) => btn.setButtonText("Cancel").setCta().onClick(() => {
          this.close();
          new import_obsidian10.Notice("Sync to flomo Canceled!");
        }));
      }
    });
  }
};

// src/action/sync-flomo-action.ts
var SyncFlomoAction = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  act(actionModels) {
    let flomoAPI = this.plugin.settings.flomoAPI;
    if (!flomoAPI || flomoAPI.trim() == "") {
      new import_obsidian11.Notice("Please config flomoAPI first!");
      return;
    }
    if (actionModels.length > 0) {
      new SyncFlomoConfirmModal(this.plugin, actionModels).open();
    } else {
      new import_obsidian11.Notice("No Files Found!");
    }
  }
};

// src/modal/choose-canvas-modal.ts
var import_obsidian14 = __toModule(require("obsidian"));

// src/action/add-to-canvas-action.ts
var import_obsidian13 = __toModule(require("obsidian"));

// src/modal/add-to-canvas-confirm-modal.ts
var import_obsidian12 = __toModule(require("obsidian"));
var width = 400;
var height = 400;
var between = 40;
var AddToCanvasConfirmModal = class extends import_obsidian12.Modal {
  constructor(app2, actionModels, targetFilePath) {
    super(app2);
    this.targetFilePath = targetFilePath;
    if (actionModels.length == 1 && actionModels[0].content) {
      this.cont = actionModels[0].content;
    } else {
      let resultArr = actionModels.map((model) => model.file);
      this.resultArr = resultArr;
    }
  }
  onOpen() {
    if (this.cont) {
      this.addContent();
    } else {
      this.addFile();
    }
  }
  addContent() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Confirm Add to Canvas?" });
    contentEl.createEl("div", { text: "Add cont below to Canvas -> " + this.targetFilePath + " !" });
    let lines = this.cont.split(/\r?\n/);
    for (const key in lines) {
      let line = lines[key];
      contentEl.createEl("div", { text: line });
    }
    new import_obsidian12.Setting(contentEl).addToggle((toggle) => {
      toggle.setTooltip("Split by line!");
      toggle.onChange((val) => {
        this.splitByLineFlag = val;
      });
    });
    new import_obsidian12.Setting(contentEl).addButton((btn) => btn.setButtonText("Confirm").setCta().onClick(() => __async(this, null, function* () {
      this.close();
      const canvasView = yield this.getCanvas();
      if ((canvasView == null ? void 0 : canvasView.getViewType()) === "canvas") {
        const canvas = canvasView == null ? void 0 : canvasView.canvas;
        if (this.splitByLineFlag) {
          let lines2 = this.cont.split(/\r?\n/);
          let idx = 0;
          for (const key in lines2) {
            let line = lines2[key];
            this.createTextNode(canvas, line, idx);
            idx++;
          }
        } else {
          this.createTextNode(canvas, this.cont, 0);
        }
        canvas.requestSave();
        new import_obsidian12.Notice("Add to Canvas Success!");
      } else {
        new import_obsidian12.Notice(this.targetFilePath + " is not a Canvas!");
      }
    }))).addButton((btn) => btn.setButtonText("Cancel").setCta().onClick(() => {
      this.close();
      new import_obsidian12.Notice("Add to Canvas Canceled!");
    }));
  }
  getCanvas() {
    return __async(this, null, function* () {
      let activeFile = this.app.workspace.getActiveFile();
      if (activeFile == null || this.targetFilePath != activeFile.path) {
        let targetFile = this.app.vault.getAbstractFileByPath(this.targetFilePath);
        if (targetFile == null) {
          console.log("can not find " + this.targetFilePath);
          targetFile = yield this.app.vault.create(this.targetFilePath, "");
        }
        yield this.app.workspace.getLeaf(activeFile != null).openFile(targetFile);
      }
      const canvasView = app.workspace.getActiveViewOfType(import_obsidian12.ItemView);
      return canvasView;
    });
  }
  addFile() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Confirm Add to Canvas?" });
    contentEl.createEl("div", { text: "Add all files below to Canvas -> " + this.targetFilePath + " !" });
    this.resultArr.forEach((info) => {
      contentEl.createEl("div", { text: info.path });
    });
    new import_obsidian12.Setting(contentEl).addToggle((toggle) => {
      toggle.setTooltip("Include resolved links!");
      toggle.onChange((val) => {
        this.includeReslovedLinksFlag = val;
      });
    });
    new import_obsidian12.Setting(contentEl).addButton((btn) => btn.setButtonText("Confirm").setCta().onClick(() => __async(this, null, function* () {
      this.close();
      let pathNodeMap = new Map();
      const canvasView = yield this.getCanvas();
      if ((canvasView == null ? void 0 : canvasView.getViewType()) === "canvas") {
        const canvas = canvasView == null ? void 0 : canvasView.canvas;
        let idx = 0;
        for (const key in this.resultArr) {
          let file = this.resultArr[key];
          let tempChildNode = this.createFileNode(canvas, file, idx);
          idx++;
          if (this.includeReslovedLinksFlag) {
            pathNodeMap.set(file.path, tempChildNode);
            let linkObj = this.app.metadataCache.resolvedLinks[file.path];
            for (let innerFilePath in linkObj) {
              let existFileNode = pathNodeMap.get(innerFilePath);
              if (existFileNode) {
                this.createEdge(tempChildNode, existFileNode, canvas);
              } else {
                console.log(innerFilePath);
                let resolvedFile = this.app.vault.getAbstractFileByPath(innerFilePath);
                console.log(resolvedFile);
                let innerChildNode = this.createFileNode(canvas, resolvedFile, idx);
                idx++;
                pathNodeMap.set(innerFilePath, innerChildNode);
                this.createEdge(tempChildNode, innerChildNode, canvas);
              }
            }
          }
        }
        canvas.requestSave();
        new import_obsidian12.Notice("Add to Canvas Success!");
      } else {
        new import_obsidian12.Notice(this.targetFilePath + " is not a Canvas!");
      }
    }))).addButton((btn) => btn.setButtonText("Cancel").setCta().onClick(() => {
      this.close();
      new import_obsidian12.Notice("Add to Canvas Canceled!");
    }));
  }
  createTextNode(canvas, cont, idx) {
    let tempChildNode;
    tempChildNode = canvas.createTextNode({
      text: cont,
      pos: {
        x: between + (width + between) * idx,
        y: between,
        width,
        height
      },
      size: {
        x: between,
        y: between,
        width,
        height
      },
      save: true,
      focus: false
    });
    canvas.deselectAll();
    canvas.addNode(tempChildNode);
    return tempChildNode;
  }
  createFileNode(canvas, file, idx) {
    let tempChildNode;
    if (!(0, import_obsidian12.requireApiVersion)("1.1.10")) {
      tempChildNode = canvas.createFileNode(file, "", { x: between + (width + between) * idx, y: between, height, width }, true);
    } else {
      tempChildNode = canvas.createFileNode({
        file,
        pos: {
          x: between + (width + between) * idx,
          y: between,
          width,
          height
        },
        size: {
          x: between,
          y: between,
          width,
          height
        },
        save: true,
        focus: false
      });
    }
    canvas.deselectAll();
    canvas.addNode(tempChildNode);
    return tempChildNode;
  }
  random(e) {
    let t = [];
    for (let n = 0; n < e; n++) {
      t.push((16 * Math.random() | 0).toString(16));
    }
    return t.join("");
  }
  createEdge(node1, node2, canvas) {
    var _a;
    const edge = canvas.edges.get((_a = canvas.getData().edges.first()) == null ? void 0 : _a.id);
    if (edge) {
      const tempEdge = new edge.constructor(canvas, this.random(16), { side: "right", node: node1 }, { side: "left", node: node2 });
      canvas.addEdge(tempEdge);
      tempEdge.attach();
      tempEdge.render();
    } else {
      console.log("You should have at least one edge in the canvas to use this feature!");
    }
  }
};

// src/action/add-to-canvas-action.ts
var AddToCanvasAction = class {
  constructor(app2, targetFilePath) {
    this.app = app2;
    this.targetFilePath = targetFilePath;
  }
  act(actionModels) {
    return __async(this, null, function* () {
      if (actionModels.length > 0) {
        new AddToCanvasConfirmModal(this.app, actionModels, this.targetFilePath).open();
      } else {
        new import_obsidian13.Notice("No Files Found!");
      }
    });
  }
};

// src/modal/choose-canvas-modal.ts
var ChooseCanvasModal = class extends import_obsidian14.SuggestModal {
  constructor(app2, readable) {
    super(app2);
    this.readable = readable;
  }
  getSuggestions(query) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const files = [];
    const lowerCaseInputStr = query.toLowerCase();
    abstractFiles.forEach((file) => {
      if (file instanceof import_obsidian14.TFile && file.path.toLowerCase().contains(lowerCaseInputStr) && file.path.toLowerCase().endsWith(".canvas")) {
        files.push(file.path);
      }
    });
    if (files.length == 0) {
      if (query.endsWith(".canvas")) {
        files.push(query);
      } else {
        files.push(query + ".canvas");
      }
    }
    return files;
  }
  renderSuggestion(filePath, el) {
    el.createEl("div", { text: filePath });
  }
  onChooseSuggestion(file, evt) {
    let action = new AddToCanvasAction(this.app, file);
    this.readable.read(action);
  }
};

// src/modal/choose-file-modal.ts
var import_obsidian17 = __toModule(require("obsidian"));

// src/action/merge-action.ts
var import_obsidian16 = __toModule(require("obsidian"));

// src/modal/merge-confirm-modal.ts
var import_obsidian15 = __toModule(require("obsidian"));

// src/utils/line-break-util.ts
function getLinebreak() {
  let oss = ["Windows", "Mac", "Linux"];
  let lineBreaks = ["\r\n", "\n", "\n"];
  for (let i = 0; i < oss.length; i++) {
    let os = oss[i];
    if (navigator.userAgent.indexOf(os) != -1) {
      return lineBreaks[i];
    }
  }
  return "\n";
}

// src/modal/merge-confirm-modal.ts
var MergeConfirmModal = class extends import_obsidian15.Modal {
  constructor(app2, resultArr, targetFilePath) {
    super(app2);
    this.targetFilePath = targetFilePath;
    this.resultArr = resultArr;
    this.lineBreak = getLinebreak();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Confirm Merge?" });
    contentEl.createEl("div", { text: "Merge all files below -> " + this.targetFilePath + " !" });
    this.resultArr.forEach((info) => {
      contentEl.createEl("div", { text: info.path });
    });
    new import_obsidian15.Setting(contentEl).addButton((btn) => btn.setButtonText("Confirm").setCta().onClick(() => __async(this, null, function* () {
      this.close();
      let targetFile = this.app.vault.getAbstractFileByPath(this.targetFilePath);
      if (targetFile == null) {
        targetFile = yield this.app.vault.create(this.targetFilePath, "");
      }
      for (const key in this.resultArr) {
        let info = this.resultArr[key];
        if (hasMarkdownSuffix(info.name)) {
          let cont = yield this.app.vault.read(info);
          cont = this.clearYaml(cont);
          cont = this.demoteHeader(cont);
          cont = "# " + info.name.substring(0, info.name.length - 3) + this.lineBreak + cont + this.lineBreak + this.lineBreak;
          yield this.app.vault.append(targetFile, cont);
        } else {
          let cont = `![[${info.name}]]${this.lineBreak}${this.lineBreak}`;
          yield this.app.vault.append(targetFile, cont);
        }
      }
      new import_obsidian15.Notice("Merge Success!");
    }))).addButton((btn) => btn.setButtonText("Cancel").setCta().onClick(() => {
      this.close();
      new import_obsidian15.Notice("Merge Canceled!");
    }));
  }
  clearYaml(cont) {
    if (cont.startsWith("---")) {
      let lines = cont.split(this.lineBreak);
      let results = "";
      let appendFlag = true;
      for (let idx in lines) {
        if (lines[idx] == "---") {
          appendFlag = !appendFlag;
          continue;
        }
        if (appendFlag) {
          results = results + lines[idx] + this.lineBreak;
        }
      }
      return results;
    } else {
      return cont;
    }
  }
  demoteHeader(cont) {
    let reg = /# /g;
    return cont.replace(reg, "## ");
  }
};

// src/action/merge-action.ts
var MergeAction = class {
  constructor(app2, targetFilePath) {
    this.app = app2;
    this.targetFilePath = targetFilePath;
  }
  act(actionModels) {
    return __async(this, null, function* () {
      if (actionModels.length > 0) {
        let files = actionModels.map((model) => model.file);
        new MergeConfirmModal(this.app, files, this.targetFilePath).open();
      } else {
        new import_obsidian16.Notice("No Files Found!");
      }
    });
  }
};

// src/modal/choose-file-modal.ts
var ChooseFileModal = class extends import_obsidian17.SuggestModal {
  constructor(app2, readable) {
    super(app2);
    this.readable = readable;
  }
  getSuggestions(query) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const files = [];
    const lowerCaseInputStr = query.toLowerCase();
    abstractFiles.forEach((file) => {
      if (file instanceof import_obsidian17.TFile && file.path.toLowerCase().contains(lowerCaseInputStr)) {
        files.push(file.path);
      }
    });
    if (files.length == 0) {
      if (hasMarkdownSuffix(query)) {
        files.push(query);
      } else {
        files.push(query + ".md");
      }
    }
    return files;
  }
  renderSuggestion(filePath, el) {
    el.createEl("div", { text: filePath });
  }
  onChooseSuggestion(file, evt) {
    let action = new MergeAction(this.app, file);
    this.readable.read(action);
  }
};

// src/modal/choose-folder-modal.ts
var import_obsidian18 = __toModule(require("obsidian"));
var ChooseFolderModal = class extends import_obsidian18.SuggestModal {
  constructor(app2, readable, actionFunc) {
    super(app2);
    this.readable = readable;
    this.actionFunc = actionFunc;
  }
  getSuggestions(query) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = query.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian18.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders;
  }
  renderSuggestion(folder, el) {
    el.createEl("div", { text: folder.path });
  }
  onChooseSuggestion(folder, evt) {
    let action = this.actionFunc(folder.path);
    this.readable.read(action);
  }
};

// src/reader/clipboard-reader.ts
var import_obsidian19 = __toModule(require("obsidian"));

// src/action/action.ts
var ActionModel = class {
  constructor(file, content) {
    this.file = file;
    this.content = content;
  }
};

// src/reader/read-info.ts
var ReadInfo = class {
  constructor(limit) {
    try {
      this.limit = limit;
    } catch (e) {
      throw new Error("limit [" + this.limit + "] must be a number!");
    }
    this.actionModels = [];
  }
  addFile(file) {
    if (this.actionModels.length >= this.limit) {
      throw new Error("Load more than " + this.limit + " files!");
    }
    let model = new ActionModel(file);
    this.actionModels.push(model);
  }
  addContent(cont) {
    if (this.actionModels.length >= this.limit) {
      throw new Error("Load more than " + this.limit + " files!");
    }
    let model = new ActionModel(null, cont);
    this.actionModels.push(model);
  }
  getModels() {
    return this.actionModels;
  }
};

// src/reader/clipboard-reader.ts
var ClipboardReader = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
  }
  read(action) {
    let readInfo = new ReadInfo(this.plugin.settings.limit);
    let promiseStr = navigator.clipboard.readText();
    promiseStr.then((str) => {
      let lines = str.split(/\r?\n/);
      try {
        lines.forEach((line) => {
          let f = line;
          if (f.startsWith("[[")) {
            f = f.substring(2, f.length);
          }
          if (f.endsWith("]]")) {
            f = f.substring(0, f.length - 2);
          }
          if (!hasMarkdownSuffix(f) && !hasCanvasSuffix(f)) {
            f = f + ".md";
          }
          let ff = this.app.vault.getAbstractFileByPath(f);
          if (ff != null) {
            readInfo.addFile(ff);
          } else {
            console.log("can not find file :" + f);
          }
        });
        action.act(readInfo.getModels());
      } catch (e) {
        new import_obsidian19.Notice(e.message);
      }
    }).catch((e) => {
      new import_obsidian19.Notice("Clipboard File Content Error!" + e);
    });
  }
};

// src/reader/clipboard-content-reader.ts
var import_obsidian20 = __toModule(require("obsidian"));
var ClipboardContentReader = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
  }
  read(action) {
    let promiseStr = navigator.clipboard.readText();
    promiseStr.then((str) => {
      try {
        let actionModels = [];
        let model = new ActionModel(null, str);
        actionModels.push(model);
        action.act(actionModels);
      } catch (e) {
        new import_obsidian20.Notice(e.message);
      }
    }).catch((e) => {
      new import_obsidian20.Notice("Clipboard Content Error!" + e);
    });
  }
};

// src/command/clipboard-command.ts
var ClipboardCommand = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  regist() {
    this.registMoveFile();
    this.registSyncFlomo();
    this.registMergeFile();
    this.registDeleteFile();
    this.registEditProp();
    this.registRenameFile();
    this.registAddFile2Canvas();
    this.registAddContToCanvas();
  }
  registRenameFile() {
    this.plugin.addCommand({
      id: "rename-files-in-clipboard",
      name: "Rename files in clipboard ...",
      callback: () => {
        new ClipboardReader(this.plugin).read(new RenameAction(this.plugin.app));
      }
    });
  }
  registEditProp() {
    this.plugin.addCommand({
      id: "edit-front-matter-in-clipboard-files",
      name: "Edit Properties in clipboard files ...",
      callback: () => {
        new ClipboardReader(this.plugin).read(new EditPropertiesAction(this.plugin.app));
      }
    });
  }
  registDeleteFile() {
    this.plugin.addCommand({
      id: "delete-files-in-clipboard",
      name: "Delete files in clipboard!",
      callback: () => {
        new ClipboardReader(this.plugin).read(new DeleteAction(this.plugin.app));
      }
    });
  }
  registMergeFile() {
    this.plugin.addCommand({
      id: "merge-files-in-clipboard-to",
      name: "Merge files in clipboard to ...",
      callback: () => {
        new ChooseFileModal(this.plugin.app, new ClipboardReader(this.plugin)).open();
      }
    });
  }
  registSyncFlomo() {
    this.plugin.addCommand({
      id: "sync-files-in-clipboard-to-flomo",
      name: "Sync files in clipboard to flomo ...",
      callback: () => {
        new ClipboardReader(this.plugin).read(new SyncFlomoAction(this.plugin));
      }
    });
  }
  registMoveFile() {
    this.plugin.addCommand({
      id: "move-files-in-clipboard-to",
      name: "Move files in clipboard to ...",
      callback: () => {
        let actionFunc = (path) => {
          return new MoveAction(this.plugin.app, path);
        };
        new ChooseFolderModal(this.plugin.app, new ClipboardReader(this.plugin), actionFunc).open();
      }
    });
  }
  registAddContToCanvas() {
    this.plugin.addCommand({
      id: "Add-content-to",
      name: "Add content in clipboard to canvas ...",
      callback: () => {
        new ChooseCanvasModal(this.plugin.app, new ClipboardContentReader(this.plugin)).open();
      }
    });
  }
  registAddFile2Canvas() {
    this.plugin.addCommand({
      id: "add-files-in-clipboard-to-canvas",
      name: "Add files in clipboard to target canvas ...",
      callback: () => {
        new ChooseCanvasModal(this.plugin.app, new ClipboardReader(this.plugin)).open();
      }
    });
  }
};

// src/action/create-action.ts
var import_obsidian22 = __toModule(require("obsidian"));

// src/modal/create-confirm-modal.ts
var import_obsidian21 = __toModule(require("obsidian"));
var CreateConfirmModal = class extends import_obsidian21.Modal {
  constructor(app2, moveInfos) {
    super(app2);
    this.moveInfos = moveInfos;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Confirm Create?" });
    this.moveInfos.forEach((info) => {
      contentEl.createEl("div", { text: info.targetDir + "/" + info.sourceFile.name });
    });
    new import_obsidian21.Setting(contentEl).addButton((btn) => btn.setButtonText("Confirm").setCta().onClick(() => __async(this, null, function* () {
      this.close();
      for (const key in this.moveInfos) {
        let info = this.moveInfos[key];
        yield this.app.vault.create(info.targetDir + "/" + info.sourceFile.name, "");
      }
      new import_obsidian21.Notice("Create Success!");
    }))).addButton((btn) => btn.setButtonText("Cancel").setCta().onClick(() => {
      this.close();
      new import_obsidian21.Notice("Create Canceled!");
    }));
  }
};

// src/action/create-action.ts
var CreateAction = class {
  constructor(app2, targetPath) {
    this.app = app2;
    this.targetPath = targetPath;
  }
  act(actionModels) {
    const moveInfos = [];
    if (actionModels.length > 0) {
      actionModels.forEach((model) => {
        let ff = model.file;
        moveInfos.push({
          sourceFile: ff,
          targetDir: this.targetPath
        });
      });
      new CreateConfirmModal(this.app, moveInfos).open();
    } else {
      new import_obsidian22.Notice("No Files Found!");
    }
  }
};

// src/reader/current-file-reader.ts
var import_obsidian23 = __toModule(require("obsidian"));
var ReadType;
(function(ReadType2) {
  ReadType2[ReadType2["LINKS"] = 0] = "LINKS";
  ReadType2[ReadType2["UN_RESOLVED_LINKS"] = 1] = "UN_RESOLVED_LINKS";
  ReadType2[ReadType2["CONTENT"] = 2] = "CONTENT";
  ReadType2[ReadType2["SELECTION"] = 3] = "SELECTION";
})(ReadType || (ReadType = {}));
var CurrentFileReader = class {
  constructor(plugin, readType, selection) {
    this.readType = 0;
    this.plugin = plugin;
    this.app = plugin.app;
    this.readType = readType;
    this.selection = selection;
  }
  read(action) {
    let readInfo = new ReadInfo(this.plugin.settings.limit);
    let currentFile = this.app.workspace.getActiveFile();
    if (currentFile == null) {
      new import_obsidian23.Notice("No active file!");
      return;
    }
    let currentFilePath = currentFile.path;
    let paths = [];
    if (this.readType == 2) {
      paths.push(currentFilePath);
    } else if (this.readType == 1) {
      let linkObj = this.app.metadataCache.unresolvedLinks[currentFilePath];
      for (let key in linkObj) {
        paths.push(key);
      }
    } else {
      let linkObj = this.app.metadataCache.resolvedLinks[currentFilePath];
      for (let key in linkObj) {
        paths.push(key);
      }
    }
    try {
      if (this.readType == 1) {
        paths.forEach((path) => {
          let ff = new VirtualFile(path);
          readInfo.addFile(ff);
        });
      } else if (this.readType == 3) {
        readInfo.addContent(this.selection);
      } else {
        paths.forEach((path) => {
          let ff = this.app.vault.getAbstractFileByPath(path);
          if (ff != null) {
            readInfo.addFile(ff);
          }
        });
      }
      action.act(readInfo.getModels());
    } catch (e) {
      new import_obsidian23.Notice(e.message);
    }
  }
};
var VirtualFile = class {
  constructor(path) {
    let idx = path.lastIndexOf("/");
    if (!hasMarkdownSuffix(path)) {
      path = path + ".md";
    }
    this.path = path;
    if (idx >= 0) {
      this.name = path.substring(idx, path.length);
    } else {
      this.name = path;
    }
  }
};

// src/command/current-file-command.ts
var CurrentFileCommand = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  regist() {
    this.registMoveFile();
    this.registSyncContentToFlomo();
    this.registSyncSelectionToFlomo();
    this.registSyncFileToFlomo();
    this.registCreateFile();
    this.registMergeFile();
    this.registDeleteFile();
    this.registEditProp();
    this.registRenameFile();
    this.registAddFile2Canvas();
    this.registAddSelectionToCanvas();
  }
  registRenameFile() {
    this.plugin.addCommand({
      id: "rename-in-current-file-links",
      name: "Rename in current file links ...",
      callback: () => {
        new CurrentFileReader(this.plugin).read(new RenameAction(this.plugin.app));
      }
    });
  }
  registEditProp() {
    this.plugin.addCommand({
      id: "edit-front-matter-in-current-file-links",
      name: "Edit Properties in current file links ...",
      callback: () => {
        new CurrentFileReader(this.plugin).read(new EditPropertiesAction(this.plugin.app));
      }
    });
  }
  registDeleteFile() {
    this.plugin.addCommand({
      id: "delete-links-in-current-file",
      name: "Delete link-files in current file!",
      callback: () => {
        new CurrentFileReader(this.plugin).read(new DeleteAction(this.plugin.app));
      }
    });
  }
  registMergeFile() {
    this.plugin.addCommand({
      id: "merge-links-to",
      name: "Merge links in current file to ...",
      callback: () => {
        new ChooseFileModal(this.plugin.app, new CurrentFileReader(this.plugin)).open();
      }
    });
  }
  registCreateFile() {
    this.plugin.addCommand({
      id: "create-links",
      name: "Create links in current file ...",
      callback: () => {
        let actionFunc = (path) => {
          return new CreateAction(this.plugin.app, path);
        };
        new ChooseFolderModal(this.plugin.app, new CurrentFileReader(this.plugin, ReadType.UN_RESOLVED_LINKS), actionFunc).open();
      }
    });
  }
  registSyncFileToFlomo() {
    this.plugin.addCommand({
      id: "sync-links-to",
      name: "Sync links in current file to flomo ...",
      callback: () => {
        new CurrentFileReader(this.plugin).read(new SyncFlomoAction(this.plugin));
      }
    });
  }
  registSyncContentToFlomo() {
    this.plugin.addCommand({
      id: "sync-content-to",
      name: "Sync content in current file to flomo ...",
      callback: () => {
        new CurrentFileReader(this.plugin, ReadType.CONTENT).read(new SyncFlomoAction(this.plugin));
      }
    });
  }
  registSyncSelectionToFlomo() {
    this.plugin.addCommand({
      id: "sync-selection-to",
      name: "Sync selection in current file to flomo ...",
      editorCheckCallback: (checking, editor, view) => {
        if (!checking) {
          new CurrentFileReader(this.plugin, ReadType.SELECTION, editor.getSelection()).read(new SyncFlomoAction(this.plugin));
        }
        return editor.getSelection() != "";
      }
    });
  }
  registAddSelectionToCanvas() {
    this.plugin.addCommand({
      id: "Add-selection-to",
      name: "Add selection in current file to canvas ...",
      editorCheckCallback: (checking, editor, view) => {
        if (!checking) {
          new ChooseCanvasModal(this.plugin.app, new CurrentFileReader(this.plugin, ReadType.SELECTION, editor.getSelection())).open();
        }
        return editor.getSelection() != "";
      }
    });
  }
  registMoveFile() {
    this.plugin.addCommand({
      id: "move-links-to",
      name: "Move links in current file to ...",
      callback: () => {
        let actionFunc = (path) => {
          return new MoveAction(this.plugin.app, path);
        };
        new ChooseFolderModal(this.plugin.app, new CurrentFileReader(this.plugin), actionFunc).open();
      }
    });
  }
  registAddFile2Canvas() {
    this.plugin.addCommand({
      id: "add-links-to-canvas",
      name: "Add links in current file to target canvas ...",
      callback: () => {
        new ChooseCanvasModal(this.plugin.app, new CurrentFileReader(this.plugin)).open();
      }
    });
  }
};

// src/command/dataview-command.ts
var import_obsidian_dataview2 = __toModule(require_lib());

// src/action/copy-action.ts
var import_obsidian25 = __toModule(require("obsidian"));

// src/modal/copy-to-clipboard-confirm-modal.ts
var import_obsidian24 = __toModule(require("obsidian"));
var CopyToClipboardConfirmModal = class extends import_obsidian24.Modal {
  constructor(app2, resultArr) {
    super(app2);
    this.resultArr = resultArr;
    this.lineBreak = getLinebreak();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Confirm copy to clipboard?" });
    let htmlStr = this.prepareHTMLStr();
    let el = contentEl.createEl("div");
    el.innerHTML = htmlStr;
    new import_obsidian24.Setting(contentEl).addToggle((toggle) => {
      toggle.setTooltip("Copy name only!");
      toggle.onChange((val) => {
        this.nameOnlyFlag = val;
        htmlStr = this.prepareHTMLStr();
        el.innerHTML = htmlStr;
      });
    });
    new import_obsidian24.Setting(contentEl).addButton((btn) => btn.setButtonText("Confirm").setCta().onClick(() => __async(this, null, function* () {
      this.close();
      let str = this.prepareStr();
      navigator.clipboard.writeText(str);
      new import_obsidian24.Notice("Copy links success!");
    }))).addButton((btn) => btn.setButtonText("Cancel").setCta().onClick(() => {
      this.close();
      new import_obsidian24.Notice("Copy to Clipboard Canceled!");
    }));
  }
  prepareStr() {
    let str = "";
    if (this.nameOnlyFlag) {
      this.resultArr.forEach((ff) => {
        let name = ff.name;
        if (hasMarkdownSuffix(name)) {
          name = name.substring(0, name.lastIndexOf("."));
        }
        str += "[[" + name + "]]" + this.lineBreak;
      });
    } else {
      this.resultArr.forEach((ff) => {
        let name = ff.name;
        if (hasMarkdownSuffix(name)) {
          name = name.substring(0, name.lastIndexOf("."));
        }
        str += "[[" + ff.path + "|" + name + "]]" + this.lineBreak;
      });
    }
    return str;
  }
  prepareHTMLStr() {
    let str = "";
    if (this.nameOnlyFlag) {
      this.resultArr.forEach((ff) => {
        let name = ff.name;
        if (hasMarkdownSuffix(name)) {
          name = name.substring(0, name.lastIndexOf("."));
        }
        str += "[[" + name + "]]<br>";
      });
    } else {
      this.resultArr.forEach((ff) => {
        let name = ff.name;
        if (hasMarkdownSuffix(name)) {
          name = name.substring(0, name.lastIndexOf("."));
        }
        str += "[[" + ff.path + "|" + name + "]]<br>";
      });
    }
    return str;
  }
};

// src/action/copy-action.ts
var CopyAction = class {
  constructor(app2) {
    this.app = app2;
  }
  act(actionModels) {
    if (actionModels.length > 0) {
      let files = actionModels.map((model) => model.file);
      new CopyToClipboardConfirmModal(this.app, files).open();
    } else {
      new import_obsidian25.Notice("No Files Found!");
    }
  }
};

// src/reader/dataview-reader.ts
var import_obsidian26 = __toModule(require("obsidian"));
var import_obsidian_dataview = __toModule(require_lib());
var DataviewReader = class {
  constructor(plugin, queryStr, taskFlag) {
    this.plugin = plugin;
    this.app = plugin.app;
    this.queryStr = queryStr;
    this.taskFlag = taskFlag;
  }
  read(action) {
    let readInfo = new ReadInfo(this.plugin.settings.limit);
    let api = (0, import_obsidian_dataview.getAPI)();
    let qStr = formatStr(this.queryStr);
    let idx = this.queryStr.indexOf(".pages(");
    if (idx > 0) {
      let tmpStr = this.queryStr.substring(idx + 7);
      let tmpIdx = tmpStr.indexOf(")");
      tmpStr = tmpStr.substring(0, tmpIdx);
      if (tmpStr.indexOf("'") >= 0 || tmpStr.indexOf('"') >= 0) {
        tmpStr = tmpStr.substring(1, tmpStr.length - 1);
      } else {
        let nTmpStr = this.queryStr.substring(0, idx);
        idx = nTmpStr.indexOf(tmpStr);
        tmpStr = nTmpStr.substring(idx + tmpStr.length);
        idx = tmpStr.indexOf("'");
        tmpStr = tmpStr.substring(idx + 1);
        idx = tmpStr.indexOf("'");
        tmpStr = tmpStr.substring(0, idx);
      }
      try {
        let resArr = api.pages(tmpStr);
        resArr.values.forEach((it) => {
          let ff = this.app.vault.getAbstractFileByPath(it.file.path);
          if (ff != null) {
            readInfo.addFile(ff);
          }
        });
        action.act(readInfo.getModels());
      } catch (e) {
        new import_obsidian26.Notice(e.message);
      }
    } else {
      api.query(qStr).then((res) => {
        if (res.successful) {
          let filePaths = [];
          if (res.value.type == "list") {
            res.value.values.forEach((it) => {
              filePaths.push(it.path);
            });
          } else if (res.value.type == "table") {
            filePaths = res.value.values;
            res.value.values.forEach((it) => {
              it.forEach((innerIt) => {
                if (innerIt && innerIt.path) {
                  filePaths.push(innerIt.path);
                  return;
                }
              });
            });
          } else {
            res.value.values.forEach((it) => {
              filePaths.push(it.link.path);
            });
          }
          try {
            if (this.taskFlag) {
              let strArr = [];
              res.value.values.forEach((it) => {
                strArr.push("- [ ] [[" + it.link.path + "|" + it.text + "]]");
              });
              let actionModels = [];
              let model = new ActionModel(null, strArr.join(getLinebreak()));
              actionModels.push(model);
              action.act(actionModels);
            } else {
              filePaths.forEach((filePath) => {
                let ff = this.app.vault.getAbstractFileByPath(filePath.toString());
                if (ff != null) {
                  readInfo.addFile(ff);
                }
              });
              action.act(readInfo.getModels());
            }
          } catch (e) {
            new import_obsidian26.Notice(e.message);
          }
        } else {
          new import_obsidian26.Notice("Query string error![" + this.queryStr + "]");
        }
      });
    }
  }
};
function formatStr(queryStr) {
  let str = queryStr.trimStart();
  let commandStr = str.substring(0, 4);
  if (commandStr.toUpperCase() == "LIST") {
    return "LIST" + str.substring(4, str.length);
  }
  if (commandStr.toUpperCase() == "TABL") {
    return "TABLE" + str.substring(5, str.length);
  }
  if (commandStr.toUpperCase() == "TASK") {
    return "TASK" + str.substring(4, str.length);
  }
  return queryStr;
}

// src/command/dataview-command.ts
var DataviewCommand = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  regist() {
    let dataviewApi = (0, import_obsidian_dataview2.getAPI)();
    this.registMoveFile(dataviewApi);
    this.registSyncFlomo(dataviewApi);
    this.registMergeFile(dataviewApi);
    this.registDeleteFile(dataviewApi);
    this.registCopyLinks(dataviewApi);
    this.registEditProp(dataviewApi);
    this.registRenameFile(dataviewApi);
    this.registAddFile2Canvas(dataviewApi);
    this.registAddTask2Canvas(dataviewApi);
  }
  registRenameFile(dataviewApi) {
    this.plugin.addCommand({
      id: "rename-in-dataview-results",
      name: "Rename in dataview results ...",
      editorCheckCallback: (checking, editor, view) => {
        if (!checking) {
          new DataviewReader(this.plugin, editor.getSelection()).read(new RenameAction(this.plugin.app));
        }
        return dataviewApi != null;
      }
    });
  }
  registEditProp(dataviewApi) {
    this.plugin.addCommand({
      id: "edit-front-matter-in-dataview-results",
      name: "Edit Properties in dataview results ...",
      editorCheckCallback: (checking, editor, view) => {
        if (!checking) {
          new DataviewReader(this.plugin, editor.getSelection()).read(new EditPropertiesAction(this.plugin.app));
        }
        return dataviewApi != null;
      }
    });
  }
  registCopyLinks(dataviewApi) {
    this.plugin.addCommand({
      id: "copy-dataview-result-links",
      name: "Copy dataview result links!",
      editorCheckCallback: (checking, editor, view) => {
        if (!checking) {
          new DataviewReader(this.plugin, editor.getSelection()).read(new CopyAction(this.plugin.app));
        }
        return dataviewApi != null;
      }
    });
  }
  registDeleteFile(dataviewApi) {
    this.plugin.addCommand({
      id: "delete-dataview-results",
      name: "Delete dataview query results!",
      editorCheckCallback: (checking, editor, view) => {
        if (!checking) {
          new DataviewReader(this.plugin, editor.getSelection()).read(new DeleteAction(this.plugin.app));
        }
        return dataviewApi != null;
      }
    });
  }
  registMergeFile(dataviewApi) {
    this.plugin.addCommand({
      id: "merge-dataview-results-to",
      name: "Merge dataview query results to ...",
      editorCheckCallback: (checking, editor, view) => {
        if (!checking) {
          new ChooseFileModal(this.plugin.app, new DataviewReader(this.plugin, editor.getSelection())).open();
        }
        return dataviewApi != null;
      }
    });
  }
  registSyncFlomo(dataviewApi) {
    this.plugin.addCommand({
      id: "sync-dataview-results-to",
      name: "Sync dataview query results to flomo ...",
      editorCheckCallback: (checking, editor, view) => {
        if (!checking) {
          new DataviewReader(this.plugin, editor.getSelection()).read(new SyncFlomoAction(this.plugin));
        }
        return dataviewApi != null;
      }
    });
  }
  registMoveFile(dataviewApi) {
    this.plugin.addCommand({
      id: "move-dataview-results-to",
      name: "Move dataview query results to ...",
      editorCheckCallback: (checking, editor, view) => {
        if (!checking) {
          let actionFunc = (path) => {
            return new MoveAction(this.plugin.app, path);
          };
          new ChooseFolderModal(this.plugin.app, new DataviewReader(this.plugin, editor.getSelection()), actionFunc).open();
        }
        return dataviewApi != null;
      }
    });
  }
  registAddFile2Canvas(dataviewApi) {
    this.plugin.addCommand({
      id: "add-dataview-results-to-canvas",
      name: "Add dataview query results to canvas...",
      editorCheckCallback: (checking, editor, view) => {
        if (!checking) {
          new ChooseCanvasModal(this.plugin.app, new DataviewReader(this.plugin, editor.getSelection())).open();
        }
        return dataviewApi != null;
      }
    });
  }
  registAddTask2Canvas(dataviewApi) {
    this.plugin.addCommand({
      id: "add-dataview-task-to-canvas",
      name: "Add dataview task to canvas...",
      editorCheckCallback: (checking, editor, view) => {
        if (!checking) {
          new ChooseCanvasModal(this.plugin.app, new DataviewReader(this.plugin, editor.getSelection(), true)).open();
        }
        return dataviewApi != null;
      }
    });
  }
};

// src/command/presentation-command.ts
var PresentationCommand = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  regist() {
    this.registStartPresentation();
    this.registStopPresentation();
  }
  registStartPresentation() {
    this.plugin.addCommand({
      id: "start-presentation",
      name: "Start Presentation",
      callback: () => {
        let fontTextSize = document.body.style.getPropertyValue("--font-text-size");
        let fileLineWidth = document.body.style.getPropertyValue("--file-line-width");
        if (fontTextSize) {
          localStorage.setItem("--font-text-size", fontTextSize);
        }
        if (fileLineWidth) {
          localStorage.setItem("--file-line-width", fileLineWidth);
        }
        document.body.style.setProperty("--font-text-size", "26px");
        document.body.style.setProperty("--file-line-width", "1000px");
      }
    });
  }
  registStopPresentation() {
    this.plugin.addCommand({
      id: "stop-presentation",
      name: "Stop Presentation",
      callback: () => {
        let fontTextSize = localStorage.getItem("--font-text-size");
        let fileLineWidth = localStorage.getItem("--file-line-width");
        if (fontTextSize) {
          document.body.style.setProperty("--font-text-size", fontTextSize);
        } else {
          document.body.style.setProperty("--font-text-size", "16px");
        }
        if (fileLineWidth) {
          document.body.style.setProperty("--file-line-width", fileLineWidth);
        } else {
          document.body.style.setProperty("--file-line-width", "700px");
        }
      }
    });
  }
};

// src/reader/search-results-reader.ts
var import_obsidian27 = __toModule(require("obsidian"));
var SearchResultsReader = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
  }
  read(action) {
    let readInfo = new ReadInfo(this.plugin.settings.limit);
    let results = this.app.workspace.getLeavesOfType("search")[0].view.dom.resultDomLookup;
    if (results.size == 0) {
      new import_obsidian27.Notice("Has no search results!Please search first!");
    } else {
      let arr = [...results.keys()];
      arr.forEach((k) => {
        let ff = this.app.vault.getAbstractFileByPath(k.path);
        if (ff != null) {
          readInfo.addFile(ff);
        } else {
          console.log("can not find file :" + k.path);
        }
      });
      action.act(readInfo.getModels());
    }
  }
};

// src/command/search-command.ts
var SearchCommand = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  regist() {
    this.registMoveFile();
    this.registSyncFlomo();
    this.registMergeFile();
    this.registDeleteFile();
    this.registEditProp();
    this.registRenameFile();
    this.registAddFile2Canvas();
  }
  registRenameFile() {
    this.plugin.addCommand({
      id: "rename-files-in-searchresults",
      name: "Rename files in searchresults ...",
      callback: () => {
        new SearchResultsReader(this.plugin).read(new RenameAction(this.plugin.app));
      }
    });
  }
  registEditProp() {
    this.plugin.addCommand({
      id: "edit-front-matter-in-searchresults-files",
      name: "Edit Properties in searchresults files ...",
      callback: () => {
        new SearchResultsReader(this.plugin).read(new EditPropertiesAction(this.plugin.app));
      }
    });
  }
  registDeleteFile() {
    this.plugin.addCommand({
      id: "delete-files-in-searchresults",
      name: "Delete files in searchresults!",
      callback: () => {
        new SearchResultsReader(this.plugin).read(new DeleteAction(this.plugin.app));
      }
    });
  }
  registMergeFile() {
    this.plugin.addCommand({
      id: "merge-files-in-searchresults-to",
      name: "Merge files in searchresults to ...",
      callback: () => {
        new ChooseFileModal(this.plugin.app, new SearchResultsReader(this.plugin)).open();
      }
    });
  }
  registSyncFlomo() {
    this.plugin.addCommand({
      id: "sync-files-in-searchresults-to-flomo",
      name: "Sync files in searchresults to flomo ...",
      callback: () => {
        new SearchResultsReader(this.plugin).read(new SyncFlomoAction(this.plugin));
      }
    });
  }
  registMoveFile() {
    this.plugin.addCommand({
      id: "move-files-in-searchresults-to",
      name: "Move files in searchresults to ...",
      callback: () => {
        let actionFunc = (path) => {
          return new MoveAction(this.plugin.app, path);
        };
        new ChooseFolderModal(this.plugin.app, new SearchResultsReader(this.plugin), actionFunc).open();
      }
    });
  }
  registAddFile2Canvas() {
    this.plugin.addCommand({
      id: "add-files-in-searchresults-to-canvas",
      name: "Add files in searchresults to target canvas ...",
      callback: () => {
        new ChooseCanvasModal(this.plugin.app, new SearchResultsReader(this.plugin)).open();
      }
    });
  }
};

// main.ts
var FileCookerPlugin = class extends import_obsidian28.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      new CurrentFileCommand(this).regist();
      new ClipboardCommand(this).regist();
      new DataviewCommand(this).regist();
      new SearchCommand(this).regist();
      new PresentationCommand(this).regist();
      this.addSettingTab(new FileCookerSettingTab(this.app, this));
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
var DEFAULT_SETTINGS = {
  flomoAPI: "",
  limit: "300"
};
var FileCookerSettingTab = class extends import_obsidian28.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for File Cooker!" });
    new import_obsidian28.Setting(containerEl).setName("Limit").setDesc("config batch file limit").addText((text) => text.setPlaceholder("Enter batch file limit").setValue(this.plugin.settings.limit).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.limit = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian28.Setting(containerEl).setName("flomoAPI").setDesc("config flomo API to sync notes").addText((text) => text.setPlaceholder("Enter flomo API").setValue(this.plugin.settings.flomoAPI).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.flomoAPI = value;
      yield this.plugin.saveSettings();
    })));
  }
};


/* nosourcemap */